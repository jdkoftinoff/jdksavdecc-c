#pragma once

/*
  Copyright (c) 2013, J.D. Koftinoff Software, Ltd.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of J.D. Koftinoff Software, Ltd. nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
*/

#include "jdksavdecc_world.h"
#include "jdksavdecc_aecp_aem.h"

#ifdef __cplusplus
extern "C" {
#endif

/** \addtogroup aem AEM - Clause 7 */
/*@{*/

/** \addtogroup aem_command AEM Commands - Clause 7.4 */
/*@{*/
#define JDKSAVDECC_AEM_LOCK_TIMEOUT_MS (60*1000)
#define JDKSAVDECC_AEM_CONTROL_VALUE_TYPE_BLOB_MAX_SIZE (394) /// See IEEE Std 1722.1-2013 Table 7.115

/** \addtogroup command command : Command Codes - Clause 7.4  */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY (0x0000)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY (0x0001)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE (0x0002)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE (0x0003)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR (0x0004)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR (0x0005)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION (0x0006)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION (0x0007)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT (0x0008)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT (0x0009)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT (0x000a)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT (0x000b)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT (0x000c)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT (0x000d)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO (0x000e)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO (0x000f)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME (0x0010)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME (0x0011)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID (0x0012)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID (0x0013)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE (0x0014)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE (0x0015)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE (0x0016)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE (0x0017)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL (0x0018)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL (0x0019)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL (0x001a)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL (0x001b)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR (0x001c)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR (0x001d)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER (0x001e)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER (0x001f)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX (0x0020)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX (0x0021)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING (0x0022)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING (0x0023)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION (0x0024)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION (0x0025)
#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION (0x0026)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO (0x0027)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH (0x0028)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS (0x0029)
#define JDKSAVDECC_AEM_COMMAND_REBOOT (0x002a)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP (0x002b)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS (0x002c)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS (0x002d)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP (0x002e)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS (0x002f)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS (0x0030)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP (0x0031)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS (0x0032)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS (0x0033)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION (0x0034)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION (0x0035)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS (0x0036)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY (0x0037)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY (0x0038)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST (0x0039)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY (0x003a)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN (0x003b)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN (0x003c)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST (0x003d)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY (0x003e)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN (0x003f)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN (0x0040)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE (0x0041)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE (0x0042)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY (0x0043)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY (0x0044)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION (0x0045)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION (0x0046)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH (0x0047)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH (0x0048)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_BACKUP (0x0049)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_BACKUP (0x004a)
#define JDKSAVDECC_AEM_COMMAND_EXPANSION (0x7fff)

#define JDKSAVDECC_AEM_NUM_COMMANDS (0x004b)

/*@}*/

/** \addtogroup command_acquire_entity ACQUIRE_ENTITY Command - Clause 7.4.1.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_AEM_ACQUIRE_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_OWNER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_acquire_entity_response ACQUIRE_ENTITY Command Response
 * - Clause 7.4.1.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_AEM_ACQUIRE_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_OWNER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_lock_entity LOCK_ENTITY Command - Clause 7.4.2.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_AEM_LOCK_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_LOCKED_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_lock_entity_response LOCK_ENTITY Response - Clause 7.4.2.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_AEM_LOCK_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_LOCKED_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_entity_available ENTITY_AVAILABLE Command - Clause 7.4.3.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_entity_available_response ENTITY_AVAILABLE Response - Clause 7.4.3.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_controller_available CONTROLLER_AVAILABLE Command - Clause 7.4.4.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_controller_available_response CONTROLLER_AVAILABLE Response - Clause 7.4.4.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_read_descriptor READ_DESCRIPTOR Command - Clause 7.4.5.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_read_descriptor_response READ_DESCRIPTOR Response - Clause 7.4.5.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_DESCRIPTOR (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_write_descriptor WRITE_DESCRIPTOR Command - Clause 7.4.6.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_write_descriptor_response WRITE_DESCRIPTOR Response - Clause 7.4.6.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_DESCRIPTOR (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_configuration SET_CONFIGURATION Command - Clause 7.4.7.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_configuration_response SET_CONFIGURATION Response Clause 7.4.7.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_configuration GET_CONFIGURATION Command - Clause 7.4.8.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_get_configuration_response SET_CONFIGURATION Response - Clause 7.4.8.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_stream_format SET_STREAM_FORMAT Command - Clause 7.4.9.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_STREAM_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_stream_format_response SET_STREAM_FORMAT Response - Clause 7.4.9.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_STREAM_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_get_stream_format GET_STREAM_FORMAT Command - Clause 7.4.10.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_stream_format_response GET_STREAM_FORMAT Response - Clause 7.4.10.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_STREAM_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_video_format SET_VIDEO_FORMAT Command - Clause 7.4.11.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_FORMAT_SPECIFIC (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_ASPECT_RATIO (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_COLOR_SPACE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_FRAME_SIZE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_set_video_format_response SET_VIDEO_FORMAT Response - Clause 7.4.11.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_FORMAT_SPECIFIC (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_ASPECT_RATIO (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_COLOR_SPACE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_FRAME_SIZE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_get_video_format GET_VIDEO_FORMAT Command - Clause - 7.4.12.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_video_format_response GET_VIDEO_FORMAT Response - Clause 7.4.12.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_FORMAT_SPECIFIC (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_ASPECT_RATIO (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_COLOR_SPACE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_FRAME_SIZE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_set_sensor_format SET_SENSOR_FORMAT Command - Clause 7.4.13.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_SENSOR_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_sensor_format_response SET_SENSOR_FORMAT Response - Clause 7.4.13.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_SENSOR_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_get_sensor_format GET_SENSOR_FORMAT Command - Clause 7.4.14.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_sensor_format_response GET_SENSOR_FORMAT Response - Clause 7.4.14.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_SENSOR_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_stream_info SET_STREAM_INFO Command - Clause 7.4.15.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_AEM_STREAM_INFO_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_ACCUMULATED_LATENCY                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 36)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_DEST_MAC (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 40)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_FAILURE_CODE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 46)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 47)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_FAILURE_BRIDGE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 48)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_VLAN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 56)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED2 (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 58)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 60)

/*@}*/

/** \addtogroup command_set_stream_info_response SET_STREAM_INFO Response - Clause 7.4.15.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_AEM_STREAM_INFO_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_ACCUMULATED_LATENCY                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 36)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_DEST_MAC (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 40)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_CODE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 46)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 47)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_BRIDGE_ID                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 48)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 56)

/*@}*/

/** \addtogroup command_get_stream_info GET_STREAM_INFO Command - Clause 7.4.16.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_stream_info_response GET_STREAM_INFO Response - Clause 7.4.16.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_AEM_STREAM_INFO_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_FORMAT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_ACCUMULATED_LATENCY                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 36)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_DEST_MAC (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 40)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_CODE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 46)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 47)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_BRIDGE_ID                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 48)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_VLAN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 56)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_RESERVED2 (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 58)
#define JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 60)

/*@}*/

/** \addtogroup command_set_name SET_NAME Command - Clause 7.4.17.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_NAME_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_NAME (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 84)

/*@}*/

/** \addtogroup command_set_name_response SET_NAME Response - Clause 7.4.17.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_NAME_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_NAME (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 84)

/*@}*/

/** \addtogroup command_get_name GET_NAME Command - Clause 7.4.18.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_NAME_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_name_response GET_NAME Response - Clause 7.4.18.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_NAME_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_CONFIGURATION_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_NAME (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 84)

/*@}*/

/** \addtogroup command_set_association_id SET_ASSOCIATION_ID Command - Clause 7.4.19.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_ASSOCIATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_set_association_id_response SET_ASSOCIATION_ID Response - Clause 7.4.19.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_ASSOCIATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_association_id GET_ASSOCIATION_ID Command - Clause 7.4.20.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_get_association_id_response GET_ASSOCIATION_ID Response - Clause 7.4.20.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_ASSOCIATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_set_sampling_rate SET_SAMPLING_RATE Command - Clause 7.4.21.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_SAMPLING_RATE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_set_sampling_rate_response SET_SAMPLING_RATE Response - Clause 7.4.21.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_SAMPLING_RATE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_sampling_rate GET_SAMPLING_RATE Command - Clause 7.4.22.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_sampling_rate_response GET_SAMPLING_RATE Response - Clause 7.4.22.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_SAMPLING_RATE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_set_clock_source SET_CLOCK_SOURCE Command - Clause 7.4.23.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_CLOCK_SOURCE_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)

/*@}*/

/** \addtogroup command_set_clock_source_response SET_CLOCK_SOURCE Response - Clause 7.4.23.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_CLOCK_SOURCE_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)

/*@}*/

/** \addtogroup command_get_clock_source GET_CLOCK_SOURCE Command - Clause 7.4.24.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_clock_source_response GET_CLOCK_SOURCE Response - Clause 7.4.24.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_CLOCK_SOURCE_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)

/*@}*/

/** \addtogroup command_set_control SET_CONTROL Command - Clause 7.4.25.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_control_response SET_CONTROL Response - Clause 7.4.25.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_control GET_CONTROL Command - Clause 7.4.26.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_control_response GET_CONTROL Response - Clause 7.4.26.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_increment_control INCREMENT_CONTROL Command - Clause 7.4.27.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_INDEX_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_increment_control_response INCREMENT_CONTROL Response - Clause 7.4.27.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_decrement_control DECREMENT_CONTROL Command - Clause 7.4.28.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_INDEX_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_decrement_control_response DECREMENT_CONTROL Response - Clause 7.4.28.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_signal_selector SET_SIGNAL_SELECTOR Command - Clause 7.4.29.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_OUTPUT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_signal_selector_response SET_SIGNAL_SELECTOR Response - Clause 7.4.29.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_OUTPUT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_get_signal_selector GET_SIGNAL_SELECTOR Command - Clause 7.4.30.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_signal_selector_response GET_SIGNAL_SELECTOR Response - Clause 7.4.30.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_OUTPUT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_mixer SET_MIXER Command - Clause 7.4.31.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_mixer_response SET_MIXER Response - Clause 7.4.31.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_mixer GET_MIXER Command - Clause 7.4.32.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_mixer_response GET_MIXER Response - Clause 7.4.32.2
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_matrix SET_MATRIX Command - Clause 7.4.33.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_MATRIX_COLUMN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_MATRIX_ROW (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REGION_WIDTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REGION_HEIGHT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REP_DIRECTION_VALUE_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_ITEM_OFFSET (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_set_matrix_response SET_MATRIX Response - Clause 7.4.33.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_MATRIX_COLUMN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_MATRIX_ROW (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REGION_WIDTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REGION_HEIGHT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REP_DIRECTION_VALUE_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_ITEM_OFFSET (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_get_matrix GET_MATRIX Command - Clause 7.4.34.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_MATRIX_COLUMN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_MATRIX_ROW (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_REGION_WIDTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_REGION_HEIGHT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_RES_DIRECTION_VALUE_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_ITEM_OFFSET (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_get_matrix_response GET_MATRIX Response - Clause 7.4.34.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_MATRIX_COLUMN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_MATRIX_ROW (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_REGION_WIDTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_REGION_HEIGHT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_RES_DIRECTION_VALUE_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_ITEM_OFFSET (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 26)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)

/*@}*/

/** \addtogroup command_start_streaming START_STREAMING Command - Clause 7.4.35.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_start_streaming_response START_STREAMING Response - Clause 7.4.35.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_stop_streaming STOP_STREAMING Command - Clause 7.4.36.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_stop_streaming_response STOP_STREAMING Response - Clause 7.4.36.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_register_unsolicited_notification
 * REGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.37.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                           \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID                                    \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_register_unsolicited_notification_response
 * REGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.37.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_SEQUENCE_ID                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_COMMAND_TYPE                                  \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_deregister_unsolicited_notification
 * DEREGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.38.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID                                  \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE                                 \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_deregister_unsolicited_notification_response
 * DEREGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.38.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_SEQUENCE_ID                                 \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_COMMAND_TYPE                                \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_identify_notification IDENTIFY_NOTIFICATION Unsolicited
 * Response - Clause 7.4.39.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_avb_info GET_AVB_INFO Command  - Clause 7.4.40.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_GPTP_GRANDMASTER_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_PROPAGATION_DELAY (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_GPTP_DOMAIN_NUMBER (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 29)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_MSRP_MAPPINGS_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 30)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_MSRP_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 32)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 32)

/*@}*/

/** \addtogroup command_get_avb_info_response GET_AVB_INFO Response  - Clause 7.4.40.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_GPTP_GRANDMASTER_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_PROPAGATION_DELAY (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_GPTP_DOMAIN_NUMBER (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 28)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_FLAGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 29)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_MSRP_MAPPINGS_COUNT (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 30)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_MSRP_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 32)
#define JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 32)

/*@}*/

/** \addtogroup command_get_as_path GET_AS_PATH Command  - Clause 7.4.41.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_as_path_response GET_AS_PATH Response  - Clause 7.4.41.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_PATH_SEQUENCE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_counters GET_COUNTERS Command  - Clause 7.4.42.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_counters_response GET_COUNTERS Response  - Clause 7.4.42.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COUNTERS_VALID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COUNTERS_BLOCK (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_reboot REBOOT Command  - Clause 7.4.43.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_reboot_response REBOOT Response - Clause 7.4.43.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_audio_map GET_AUDIO_MAP Command  - Clause 7.4.44.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_MAP_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_audio_map_response GET_AUDIO_MAP Response  - Clause 7.4.44.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_MAP_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_add_audio_mappings ADD_AUDIO_MAPPINGS Command  - Clause 7.4.45.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_add_audio_mappings_response ADD_AUDIO_MAPPINGS Response
 * - Clause 7.4.45.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_remove_audio_mappings REMOVE_AUDIO_MAPPINGS Command  -
 * Clause 7.4.46.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_remove_audio_mappings_response REMOVE_AUDIO_MAPPINGS
 * Response  - Clause 7.4.46.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                      \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_video_map GET_VIDEO_MAP Command  - Clause 7.4.47.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_MAP_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_video_map_response GET_VIDEO_MAP Response  - Clause 7.4.47.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_MAP_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_add_video_mappings ADD_VIDEO_MAPPINGS Command  - Clause 7.4.48.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_add_video_mappings_response ADD_VIDEO_MAPPINGS Response
 * - Clause 7.4.48.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_remove_video_mappings REMOVE_VIDEO_MAPPINGS Command  -
 * Clause 7.4.49.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_remove_video_mappings_response REMOVE_VIDEO_MAPPINGS
 * Response  - Clause 7.4.49.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                      \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_sensor_map GET_SENSOR_MAP Command  - Clause 7.4.50.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_MAP_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_get_sensor_map_response GET_SENSOR_MAP Response  -
 * Clause 7.4.50.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_MAP_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_add_sensor_mappings ADD_SENSOR_MAPPINGS Command  -
 * Clause 7.4.51.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_add_sensor_mappings_response ADD_SENSOR_MAPPINGS
 * Response  - Clause 7.4.51.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_remove_sensor_mappings REMOVE_SENSOR_MAPPINGS Command  -
 * Clause 7.4.52.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                      \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_remove_sensor_mappings_response REMOVE_SENSOR_MAPPINGS
 * Response  - Clause 7.4.52.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                     \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_MAPPINGS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_start_operation START_OPERATION Command  - Clause 7.4.53.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_OPERATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_OPERATION_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_start_operation_response START_OPERATION Response  -
 * Clause 7.4.53.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_OPERATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_OPERATION_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_VALUES (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_abort_operation ABORT_OPERATION Command  - Clause 7.4.54.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_OPERATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_abort_operation_response ABORT_OPERATION Response  -
 * Clause 7.4.54.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_OPERATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_operation_status_response OPERATION_STATUS Unsolicited
 * Response  - Clause 7.4.55.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_OPERATION_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_PERCENT_COMPLETE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_add_key AUTH_ADD_KEY Command  - Clause 7.4.56.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY_TYPE_KEY_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_auth_add_key_response AUTH_ADD_KEY Response  - Clause 7.4.56.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_delete_key AUTH_DELETE_KEY Command  - Clause 7.4.57.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_delete_key_response AUTH_DELETE_KEY Response  -
 * Clause 7.4.57.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_get_key_list AUTH_GET_KEY_LIST Command  - Clause 7.4.58.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_KEYCHAINID_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)

/*@}*/

/** \addtogroup command_auth_get_key_list_response AUTH_GET_KEY_LIST Response  -
 * Clause 7.4.58.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_KEYCHAINID_NUMBER_OF_KEYS                                     \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_auth_get_key AUTH_GET_KEY Command  - Clause 7.4.59.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_get_key_response AUTH_GET_KEY Response  - Clause 7.4.59.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY_TYPE_KEY_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 22)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_auth_add_key_to_chain AUTH_ADD_KEY_TO_CHAIN Command  -
 * Clause 7.4.60.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_KEYCHAIN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_auth_add_key_to_chain_response AUTH_ADD_KEY_TO_CHAIN
 * Response  - Clause 7.4.60.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                      \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_KEYCHAIN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_auth_delete_key_from_chain AUTH_DELETE_KEY_FROM_CHAIN
 * Command  - Clause 7.4.61.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                  \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_COMMAND_TYPE                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_KEYCHAIN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_auth_delete_key_from_chain_response
 * AUTH_DELETE_KEY_FROM_CHAIN Response  - Clause 7.4.61.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                 \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_COMMAND_TYPE                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_KEYCHAIN_ID                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_auth_get_keychain_list AUTH_GET_KEYCHAIN_LIST Command  -
 * Clause 7.4.62.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                      \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_KEYCHAIN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_LIST_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_auth_get_keychain_list_response AUTH_GET_KEYCHAIN_LIST
 * Response  - Clause 7.4.62.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                     \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_KEYCHAIN_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_LIST_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_NUMBER_OF_LISTS                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_NUMBER_OF_KEYS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_KEY_IDS (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_get_identity AUTH_GET_IDENTITY Command  - Clause 7.4.63.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_auth_get_identity_response AUTH_GET_IDENTITY Response  -
 * Clause 7.4.62.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_KEY_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_SIGNATURE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_auth_add_token AUTH_ADD_TOKEN Command  - Clause 7.4.64.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_TOKEN_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_AUTHENTICATION_TOKEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_auth_add_token_response AUTH_ADD_TOKEN Response  -
 * Clause 7.4.64.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_auth_delete_token AUTH_DELETE_TOKEN Command  - Clause 7.4.65.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_auth_delete_token_response AUTH_DELETE_TOKEN Response  -
 * Clause 7.4.65.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_authenticate AUTHENTICATE Command  - Clause 7.4.66.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_TOKEN_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_RESERVED (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 18)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_AUTHENTICATION_TOKEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_authenticate_response AUTHENTICATE Response  - Clause 7.4.66.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_deauthenticate DEAUTHENTICATE Command  - Clause 7.4.67.1
 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_deauthenticate_response DEAUTHENTICATE Response  -
 * Clause 7.4.67.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_enable_transport_security ENABLE_TRANSPORT_SECURITY
 * Command  - Clause 7.4.68.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_enable_transport_security_response
 * ENABLE_TRANSPORT_SECURITY Response  - Clause 7.4.68.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                  \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_COMMAND_TYPE                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 20)

/*@}*/

/** \addtogroup command_disable_transport_security DISABLE_TRANSPORT_SECURITY
 * Command  - Clause 7.4.69.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                  \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_COMMAND_TYPE                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_disable_transport_security_response
 * DISABLE_TRANSPORT_SECURITY Response  - Clause 7.4.69.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                 \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_COMMAND_TYPE                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)

/*@}*/

/** \addtogroup command_enable_stream_encryption ENABLE_STREAM_ENCRYPTION
 * Command  - Clause 7.4.70.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                    \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_TYPE                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_INDEX                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_enable_stream_encryption_response
 * ENABLE_STREAM_ENCRYPTION Response  - Clause 7.4.70.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_TYPE                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_KEY_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_disable_stream_encryption DISABLE_STREAM_ENCRYPTION
 * Command  - Clause 7.4.71.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_TYPE                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_INDEX                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_disable_stream_encryption_response
 * DISABLE_STREAM_ENCRYPTION Response  - Clause 7.4.71.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                  \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_COMMAND_TYPE                                          \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_TYPE                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                      \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_set_memory_object_length SET_MEMORY_OBJECT_LENGTH
 * Command  - Clause 7.4.72.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                    \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_TYPE                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_INDEX                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_set_memory_object_length_response
 * SET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.72.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_TYPE                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** \addtogroup command_get_memory_object_length GET_MEMORY_OBJECT_LENGTH
 * Command  - Clause 7.4.73.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID                                    \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_TYPE                                         \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_INDEX                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)

/*@}*/

/** \addtogroup command_get_memory_object_length_response
 * GET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.73.2 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID                                   \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 0)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_SEQUENCE_ID (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 8)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_COMMAND_TYPE (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 10)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_TYPE                                        \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 12)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_INDEX                                       \
    (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 14)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_LENGTH (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 16)
#define JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_LEN (JDKSAVDECC_COMMON_CONTROL_HEADER_LEN + 24)

/*@}*/

/** @todo Add offsets for fields for the rest of the commands:
JDKSAVDECC_AEM_COMMAND_SET_STREAM_BACKUP
JDKSAVDECC_AEM_COMMAND_GET_STREAM_BACKUP
*/

/** @todo Add defs Table 7.6.1.2 Key Types, 7.6.1.2.3 ECC_PUBLIC_256, 7.6.1.2.4
 * ECC_PRIVATE_256, 7.6.1.3 Key Chains */

/** \addtogroup command_acquire_entity ACQUIRE_ENTITY Command - Clause 7.4.1.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_acquire_entity_get_controller_entity_id(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_acquire_entity_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_ACQUIRE_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_ACQUIRE_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint32 value of the aem_acquire_flags field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_acquire_flags value
 */
static inline uint32_t jdksavdecc_aem_command_acquire_entity_get_aem_acquire_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_AEM_ACQUIRE_FLAGS);
}

/**
 * Store a uint32 value to the aem_acquire_flags field of the
 *COMMAND_ACQUIRE_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_acquire_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_set_aem_acquire_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_AEM_ACQUIRE_FLAGS);
}

/**
 * Extract the eui64 value of the owner_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 owner_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_acquire_entity_get_owner_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_OWNER_ENTITY_ID);
}

/**
 * Store a eui64 value to the owner_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 owner_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_acquire_entity_set_owner_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_OWNER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ACQUIRE_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ACQUIRE_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ACQUIRE_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_acquire_entity ACQUIRE_ENTITY Command - Clause 7.4.1.1
 */
/*@{*/

/// ACQUIRE_ENTITY Command - Clause 7.4.1.1
struct jdksavdecc_aem_command_acquire_entity {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint32_t aem_acquire_flags;
    struct jdksavdecc_eui64 owner_entity_id;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_acquire_entity structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_acquire_entity structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_acquire_entity_read(struct jdksavdecc_aem_command_acquire_entity *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->aem_acquire_flags = jdksavdecc_aem_command_acquire_entity_get_aem_acquire_flags(base, pos);
        p->owner_entity_id = jdksavdecc_aem_command_acquire_entity_get_owner_entity_id(base, pos);
        p->descriptor_type = jdksavdecc_aem_command_acquire_entity_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_acquire_entity_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_acquire_entity structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_acquire_entity structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_acquire_entity_write(struct jdksavdecc_aem_command_acquire_entity const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_acquire_entity_set_aem_acquire_flags(p->aem_acquire_flags, base, pos);
        jdksavdecc_aem_command_acquire_entity_set_owner_entity_id(p->owner_entity_id, base, pos);
        jdksavdecc_aem_command_acquire_entity_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_acquire_entity_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_acquire_entity_response ACQUIRE_ENTITY Command Response
 * - Clause 7.4.1.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_acquire_entity_response_get_controller_entity_id(void const *base,
                                                                                                              ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_acquire_entity_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint32 value of the aem_acquire_flags field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_acquire_flags value
 */
static inline uint32_t jdksavdecc_aem_command_acquire_entity_response_get_aem_acquire_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_AEM_ACQUIRE_FLAGS);
}

/**
 * Store a uint32 value to the aem_acquire_flags field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_acquire_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_response_set_aem_acquire_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_AEM_ACQUIRE_FLAGS);
}

/**
 * Extract the eui64 value of the owner_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 owner_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_acquire_entity_response_get_owner_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_OWNER_ENTITY_ID);
}

/**
 * Store a eui64 value to the owner_entity_id field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 owner_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_acquire_entity_response_set_owner_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_OWNER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_acquire_entity_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ACQUIRE_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_acquire_entity_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_acquire_entity_response ACQUIRE_ENTITY Command Response
 * - Clause 7.4.1.1 */
/*@{*/

/// ACQUIRE_ENTITY Command Response - Clause 7.4.1.1
struct jdksavdecc_aem_command_acquire_entity_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint32_t aem_acquire_flags;
    struct jdksavdecc_eui64 owner_entity_id;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_acquire_entity_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_acquire_entity_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_acquire_entity_response_read(
    struct jdksavdecc_aem_command_acquire_entity_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->aem_acquire_flags = jdksavdecc_aem_command_acquire_entity_response_get_aem_acquire_flags(base, pos);
        p->owner_entity_id = jdksavdecc_aem_command_acquire_entity_response_get_owner_entity_id(base, pos);
        p->descriptor_type = jdksavdecc_aem_command_acquire_entity_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_acquire_entity_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_acquire_entity_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_acquire_entity_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_acquire_entity_response_write(
    struct jdksavdecc_aem_command_acquire_entity_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ACQUIRE_ENTITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_acquire_entity_response_set_aem_acquire_flags(p->aem_acquire_flags, base, pos);
        jdksavdecc_aem_command_acquire_entity_response_set_owner_entity_id(p->owner_entity_id, base, pos);
        jdksavdecc_aem_command_acquire_entity_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_acquire_entity_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_lock_entity LOCK_ENTITY Command - Clause 7.4.2.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_LOCK_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_lock_entity_get_controller_entity_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_LOCK_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_lock_entity_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_LOCK_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_lock_entity_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_LOCK_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_LOCK_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_lock_entity_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_LOCK_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint32 value of the aem_lock_flags field of the
 *COMMAND_LOCK_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_lock_flags value
 */
static inline uint32_t jdksavdecc_aem_command_lock_entity_get_aem_lock_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_AEM_LOCK_FLAGS);
}

/**
 * Store a uint32 value to the aem_lock_flags field of the COMMAND_LOCK_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_lock_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_set_aem_lock_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_AEM_LOCK_FLAGS);
}

/**
 * Extract the eui64 value of the locked_entity_id field of the
 *COMMAND_LOCK_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 locked_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_lock_entity_get_locked_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_LOCKED_ENTITY_ID);
}

/**
 * Store a eui64 value to the locked_entity_id field of the COMMAND_LOCK_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 locked_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_set_locked_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_LOCKED_ENTITY_ID);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_LOCK_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_lock_entity_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_LOCK_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_LOCK_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_lock_entity_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_LOCK_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_lock_entity LOCK_ENTITY Command - Clause 7.4.2.1 */
/*@{*/

/// LOCK_ENTITY Command - Clause 7.4.2.1
struct jdksavdecc_aem_command_lock_entity {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint32_t aem_lock_flags;
    struct jdksavdecc_eui64 locked_entity_id;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_lock_entity structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_lock_entity structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_lock_entity_read(struct jdksavdecc_aem_command_lock_entity *p,
                                                              void const *base,
                                                              ssize_t pos,
                                                              size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->aem_lock_flags = jdksavdecc_aem_command_lock_entity_get_aem_lock_flags(base, pos);
        p->locked_entity_id = jdksavdecc_aem_command_lock_entity_get_locked_entity_id(base, pos);
        p->descriptor_type = jdksavdecc_aem_command_lock_entity_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_lock_entity_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_lock_entity structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_lock_entity structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_lock_entity_write(struct jdksavdecc_aem_command_lock_entity const *p,
                                                               void *base,
                                                               size_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_lock_entity_set_aem_lock_flags(p->aem_lock_flags, base, pos);
        jdksavdecc_aem_command_lock_entity_set_locked_entity_id(p->locked_entity_id, base, pos);
        jdksavdecc_aem_command_lock_entity_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_lock_entity_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_lock_entity_response LOCK_ENTITY Response - Clause 7.4.2.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_lock_entity_response_get_controller_entity_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_lock_entity_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_lock_entity_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_lock_entity_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint32 value of the aem_lock_flags field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_lock_flags value
 */
static inline uint32_t jdksavdecc_aem_command_lock_entity_response_get_aem_lock_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_AEM_LOCK_FLAGS);
}

/**
 * Store a uint32 value to the aem_lock_flags field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_lock_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_lock_entity_response_set_aem_lock_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_AEM_LOCK_FLAGS);
}

/**
 * Extract the eui64 value of the locked_entity_id field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 locked_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_lock_entity_response_get_locked_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_LOCKED_ENTITY_ID);
}

/**
 * Store a eui64 value to the locked_entity_id field of the
 *COMMAND_LOCK_ENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 locked_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_lock_entity_response_set_locked_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_OFFSET_LOCKED_ENTITY_ID);
}

/*@}*/

/** \addtogroup command_lock_entity_response LOCK_ENTITY Response - Clause 7.4.2.1 */
/*@{*/

/// LOCK_ENTITY Response - Clause 7.4.2.1
struct jdksavdecc_aem_command_lock_entity_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint32_t aem_lock_flags;
    struct jdksavdecc_eui64 locked_entity_id;
};

/**
 * Extract the jdksavdecc_aem_command_lock_entity_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_lock_entity_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_lock_entity_response_read(struct jdksavdecc_aem_command_lock_entity_response *p,
                                                                       void const *base,
                                                                       ssize_t pos,
                                                                       size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->aem_lock_flags = jdksavdecc_aem_command_lock_entity_response_get_aem_lock_flags(base, pos);
        p->locked_entity_id = jdksavdecc_aem_command_lock_entity_response_get_locked_entity_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_lock_entity_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_lock_entity_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_lock_entity_response_write(
    struct jdksavdecc_aem_command_lock_entity_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_LOCK_ENTITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_lock_entity_response_set_aem_lock_flags(p->aem_lock_flags, base, pos);
        jdksavdecc_aem_command_lock_entity_response_set_locked_entity_id(p->locked_entity_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_entity_available ENTITY_AVAILABLE Command - Clause 7.4.3.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ENTITY_AVAILABLE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_entity_available_get_controller_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ENTITY_AVAILABLE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_entity_available_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ENTITY_AVAILABLE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_entity_available_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_ENTITY_AVAILABLE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_entity_available_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ENTITY_AVAILABLE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_entity_available_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ENTITY_AVAILABLE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_entity_available_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_entity_available ENTITY_AVAILABLE Command - Clause 7.4.3.1 */
/*@{*/

/// ENTITY_AVAILABLE Command - Clause 7.4.3.1
struct jdksavdecc_aem_command_entity_available {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_entity_available_t structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_entity_available structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_entity_available_read(struct jdksavdecc_aem_command_entity_available *p,
                                                                   void const *base,
                                                                   ssize_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_entity_available_t structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_entity_available structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_entity_available_write(struct jdksavdecc_aem_command_entity_available const *p,
                                                                    void *base,
                                                                    size_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_entity_available_response ENTITY_AVAILABLE Response -
 * Clause 7.4.3.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ENTITY_AVAILABLE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_entity_available_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ENTITY_AVAILABLE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_entity_available_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ENTITY_AVAILABLE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_entity_available_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ENTITY_AVAILABLE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_entity_available_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ENTITY_AVAILABLE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_entity_available_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ENTITY_AVAILABLE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_entity_available_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_entity_available_response ENTITY_AVAILABLE Response -
 * Clause 7.4.3.1 */
/*@{*/

/// ENTITY_AVAILABLE Response - Clause 7.4.3.1
struct jdksavdecc_aem_command_entity_available_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_entity_available_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_entity_available_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_entity_available_response_read(
    struct jdksavdecc_aem_command_entity_available_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_entity_available_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_entity_available_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_entity_available_response_write(
    struct jdksavdecc_aem_command_entity_available_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENTITY_AVAILABLE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_controller_available CONTROLLER_AVAILABLE Command -
 * Clause 7.4.4.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_CONTROLLER_AVAILABLE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_controller_available_get_controller_entity_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_CONTROLLER_AVAILABLE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_controller_available_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_CONTROLLER_AVAILABLE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_controller_available_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_CONTROLLER_AVAILABLE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_controller_available_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_CONTROLLER_AVAILABLE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_controller_available_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_CONTROLLER_AVAILABLE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_controller_available_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_controller_available CONTROLLER_AVAILABLE Command -
 * Clause 7.4.4.1 */
/*@{*/

/// CONTROLLER_AVAILABLE Command - Clause 7.4.4.1
struct jdksavdecc_aem_command_controller_available {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_controller_available_t structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_controller_available structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_controller_available_read(struct jdksavdecc_aem_command_controller_available *p,
                                                                       void const *base,
                                                                       ssize_t pos,
                                                                       size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_controller_available_t structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_controller_available structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_controller_available_write(struct jdksavdecc_aem_command_controller_available *p,
                                                                        void *base,
                                                                        size_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_controller_available_response CONTROLLER_AVAILABLE
 * Response - Clause 7.4.4.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_CONTROLLER_AVAILABLE_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_controller_available_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_CONTROLLER_AVAILABLE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_controller_available_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                 void *base,
                                                                                                 ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_CONTROLLER_AVAILABLE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_controller_available_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_CONTROLLER_AVAILABLE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_controller_available_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_CONTROLLER_AVAILABLE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_controller_available_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_CONTROLLER_AVAILABLE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_controller_available_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_controller_available_response CONTROLLER_AVAILABLE
 * Response - Clause 7.4.4.1 */
/*@{*/

/// CONTROLLER_AVAILABLE Response - Clause 7.4.4.1
struct jdksavdecc_aem_command_controller_available_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_controller_available_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_controller_available_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_controller_available_response_read(
    struct jdksavdecc_aem_command_controller_available_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_controller_available_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_controller_available_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_controller_available_response_write(
    struct jdksavdecc_aem_command_controller_available_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_CONTROLLER_AVAILABLE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_read_descriptor READ_DESCRIPTOR Command - Clause 7.4.5.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_READ_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_read_descriptor_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_READ_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_read_descriptor_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_READ_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_READ_DESCRIPTOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_READ_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_READ_DESCRIPTOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_READ_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_READ_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_READ_DESCRIPTOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_READ_DESCRIPTOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_RESERVED);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_READ_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_READ_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_READ_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_READ_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_read_descriptor READ_DESCRIPTOR Command - Clause 7.4.5.1
 */
/*@{*/

/// READ_DESCRIPTOR Command - Clause 7.4.5.1
struct jdksavdecc_aem_command_read_descriptor {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t configuration_index;
    uint16_t reserved;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_read_descriptor structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_read_descriptor structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_read_descriptor_read(struct jdksavdecc_aem_command_read_descriptor *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->configuration_index = jdksavdecc_aem_command_read_descriptor_get_configuration_index(base, pos);
        p->reserved = jdksavdecc_aem_command_read_descriptor_get_reserved(base, pos);
        p->descriptor_type = jdksavdecc_aem_command_read_descriptor_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_read_descriptor_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_read_descriptor structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_read_descriptor structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_read_descriptor_write(struct jdksavdecc_aem_command_read_descriptor const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_read_descriptor_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_read_descriptor_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_read_descriptor_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_read_descriptor_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_read_descriptor_response READ_DESCRIPTOR Response -
 * Clause 7.4.5.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_read_descriptor_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_read_descriptor_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_response_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_read_descriptor_response_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_read_descriptor_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_READ_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_read_descriptor_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_read_descriptor_response READ_DESCRIPTOR Response -
 * Clause 7.4.5.2 */
/*@{*/

/// READ_DESCRIPTOR Response - Clause 7.4.5.2
struct jdksavdecc_aem_command_read_descriptor_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t configuration_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_read_descriptor_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_read_descriptor_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_read_descriptor_response_read(
    struct jdksavdecc_aem_command_read_descriptor_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->configuration_index = jdksavdecc_aem_command_read_descriptor_response_get_configuration_index(base, pos);
        p->reserved = jdksavdecc_aem_command_read_descriptor_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_read_descriptor_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_read_descriptor_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_read_descriptor_response_write(
    struct jdksavdecc_aem_command_read_descriptor_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_READ_DESCRIPTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_read_descriptor_response_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_read_descriptor_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_write_descriptor WRITE_DESCRIPTOR Command - Clause 7.4.6.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_WRITE_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_write_descriptor_get_controller_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_WRITE_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_write_descriptor_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_WRITE_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_WRITE_DESCRIPTOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_WRITE_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_WRITE_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_WRITE_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_WRITE_DESCRIPTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_WRITE_DESCRIPTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_WRITE_DESCRIPTOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_write_descriptor WRITE_DESCRIPTOR Command - Clause 7.4.6.1 */
/*@{*/

/// WRITE_DESCRIPTOR Command - Clause 7.4.6.1
struct jdksavdecc_aem_command_write_descriptor {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t configuration_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_write_descriptor structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_write_descriptor structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_write_descriptor_read(struct jdksavdecc_aem_command_write_descriptor *p,
                                                                   void const *base,
                                                                   ssize_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->configuration_index = jdksavdecc_aem_command_write_descriptor_get_configuration_index(base, pos);
        p->reserved = jdksavdecc_aem_command_write_descriptor_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_write_descriptor structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_write_descriptor structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_write_descriptor_write(struct jdksavdecc_aem_command_write_descriptor const *p,
                                                                    void *base,
                                                                    size_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_write_descriptor_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_write_descriptor_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_write_descriptor_response WRITE_DESCRIPTOR Response -
 * Clause 7.4.6.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_write_descriptor_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_write_descriptor_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_response_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_write_descriptor_response_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_write_descriptor_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_WRITE_DESCRIPTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_write_descriptor_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_write_descriptor_response WRITE_DESCRIPTOR Response -
 * Clause 7.4.6.1 */
/*@{*/

/// WRITE_DESCRIPTOR Response - Clause 7.4.6.1
struct jdksavdecc_aem_command_write_descriptor_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t configuration_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_write_descriptor_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_write_descriptor_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_write_descriptor_response_read(
    struct jdksavdecc_aem_command_write_descriptor_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->configuration_index = jdksavdecc_aem_command_write_descriptor_response_get_configuration_index(base, pos);
        p->reserved = jdksavdecc_aem_command_write_descriptor_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_write_descriptor_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_write_descriptor_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_write_descriptor_response_write(
    struct jdksavdecc_aem_command_write_descriptor_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_WRITE_DESCRIPTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_write_descriptor_response_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_write_descriptor_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_configuration SET_CONFIGURATION Command - Clause 7.4.7.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_configuration_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_configuration_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_SET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_SET_CONFIGURATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_RESERVED);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_SET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_SET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/*@}*/

/** \addtogroup command_set_configuration SET_CONFIGURATION Command - Clause 7.4.7.1 */
/*@{*/

/// SET_CONFIGURATION Command - Clause 7.4.7.1
struct jdksavdecc_aem_command_set_configuration {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t reserved;
    uint16_t configuration_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_configuration structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_configuration structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_configuration_read(struct jdksavdecc_aem_command_set_configuration *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->reserved = jdksavdecc_aem_command_set_configuration_get_reserved(base, pos);
        p->configuration_index = jdksavdecc_aem_command_set_configuration_get_configuration_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_configuration structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_configuration structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_configuration_write(struct jdksavdecc_aem_command_set_configuration const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_configuration_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_set_configuration_set_configuration_index(p->configuration_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_configuration_response SET_CONFIGURATION Response -
 * Clause 7.4.7.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_configuration_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_configuration_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_configuration_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_RESERVED);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_configuration_response_get_configuration_index(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_SET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_configuration_response_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/*@}*/

/** \addtogroup command_set_configuration_response SET_CONFIGURATION Response -
 * Clause 7.4.7.1 */
/*@{*/

/// SET_CONFIGURATION Response - Clause 7.4.7.1
struct jdksavdecc_aem_command_set_configuration_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t reserved;
    uint16_t configuration_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_configuration_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_configuration_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_configuration_response_read(
    struct jdksavdecc_aem_command_set_configuration_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->reserved = jdksavdecc_aem_command_set_configuration_response_get_reserved(base, pos);
        p->configuration_index = jdksavdecc_aem_command_set_configuration_response_get_configuration_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_configuration_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_configuration_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_configuration_response_write(
    struct jdksavdecc_aem_command_set_configuration_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONFIGURATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_configuration_response_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_set_configuration_response_set_configuration_index(p->configuration_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_configuration GET_CONFIGURATION Command - Clause 7.4.8.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_configuration_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_configuration_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_configuration_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_configuration_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_configuration_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_configuration_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_get_configuration GET_CONFIGURATION Command - Clause 7.4.8.1 */
/*@{*/

/// GET_CONFIGURATION Command - Clause 7.4.8.1
struct jdksavdecc_aem_command_get_configuration {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_get_configuration structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_configuration structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_configuration_read(struct jdksavdecc_aem_command_get_configuration *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_configuration structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_configuration structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_configuration_write(struct jdksavdecc_aem_command_get_configuration const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_configuration_response SET_CONFIGURATION Response -
 * Clause 7.4.8.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_configuration_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_configuration_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_configuration_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_configuration_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_configuration_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_configuration_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_configuration_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_configuration_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_RESERVED);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_configuration_response_get_configuration_index(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_GET_CONFIGURATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_configuration_response_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/*@}*/

/** \addtogroup command_get_configuration_response SET_CONFIGURATION Response -
 * Clause 7.4.8.2 */
/*@{*/

/// SET_CONFIGURATION Response - Clause 7.4.8.2
struct jdksavdecc_aem_command_get_configuration_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t reserved;
    uint16_t configuration_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_configuration_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_configuration_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_configuration_response_read(
    struct jdksavdecc_aem_command_get_configuration_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->reserved = jdksavdecc_aem_command_get_configuration_response_get_reserved(base, pos);
        p->configuration_index = jdksavdecc_aem_command_get_configuration_response_get_configuration_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_configuration_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_configuration_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_configuration_response_write(
    struct jdksavdecc_aem_command_get_configuration_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONFIGURATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_configuration_response_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_get_configuration_response_set_configuration_index(p->configuration_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_stream_format SET_STREAM_FORMAT Command - Clause 7.4.9.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_format_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_format_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the stream_format field of the
 *COMMAND_SET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_format_get_stream_format(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_STREAM_FORMAT);
}

/**
 * Store a eui64 value to the stream_format field of the
 *COMMAND_SET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_format_set_stream_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_OFFSET_STREAM_FORMAT);
}

/*@}*/

/** \addtogroup command_set_stream_format SET_STREAM_FORMAT Command - Clause 7.4.9.1 */
/*@{*/

/// SET_STREAM_FORMAT Command - Clause 7.4.9.1
struct jdksavdecc_aem_command_set_stream_format {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 stream_format;
};

/**
 * Extract the jdksavdecc_aem_command_set_stream_format structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_stream_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_format_read(struct jdksavdecc_aem_command_set_stream_format *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_stream_format_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_stream_format_get_descriptor_index(base, pos);
        p->stream_format = jdksavdecc_aem_command_set_stream_format_get_stream_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_stream_format structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_stream_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_format_write(struct jdksavdecc_aem_command_set_stream_format const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_stream_format_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_stream_format_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_stream_format_set_stream_format(p->stream_format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_stream_format_response SET_STREAM_FORMAT Response -
 * Clause 7.4.9.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_stream_format_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_format_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_format_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_format_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the stream_format field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_format_response_get_stream_format(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_STREAM_FORMAT);
}

/**
 * Store a eui64 value to the stream_format field of the
 *COMMAND_SET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_format_response_set_stream_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_OFFSET_STREAM_FORMAT);
}

/*@}*/

/** \addtogroup command_set_stream_format_response SET_STREAM_FORMAT Response -
 * Clause 7.4.9.1 */
/*@{*/

/// SET_STREAM_FORMAT Response - Clause 7.4.9.1
struct jdksavdecc_aem_command_set_stream_format_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 stream_format;
};

/**
 * Extract the jdksavdecc_aem_command_set_stream_format_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_stream_format_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_format_response_read(
    struct jdksavdecc_aem_command_set_stream_format_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_stream_format_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_stream_format_response_get_descriptor_index(base, pos);
        p->stream_format = jdksavdecc_aem_command_set_stream_format_response_get_stream_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_stream_format_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_stream_format_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_format_response_write(
    struct jdksavdecc_aem_command_set_stream_format_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_stream_format_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_stream_format_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_stream_format_response_set_stream_format(p->stream_format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_stream_format GET_STREAM_FORMAT Command - Clause 7.4.10.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_stream_format_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_format_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_STREAM_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_STREAM_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_stream_format GET_STREAM_FORMAT Command - Clause 7.4.10.1 */
/*@{*/

/// GET_STREAM_FORMAT Command - Clause 7.4.10.1
struct jdksavdecc_aem_command_get_stream_format {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_stream_format structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_stream_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_format_read(struct jdksavdecc_aem_command_get_stream_format *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_stream_format_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_stream_format_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_stream_format structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_stream_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_format_write(struct jdksavdecc_aem_command_get_stream_format const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_stream_format_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_stream_format_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_stream_format_response GET_STREAM_FORMAT Response -
 * Clause 7.4.10.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_stream_format_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_format_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_format_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_format_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the stream_format field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_stream_format_response_get_stream_format(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_STREAM_FORMAT);
}

/**
 * Store a eui64 value to the stream_format field of the
 *COMMAND_GET_STREAM_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_format_response_set_stream_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_OFFSET_STREAM_FORMAT);
}

/*@}*/

/** \addtogroup command_get_stream_format_response GET_STREAM_FORMAT Response -
 * Clause 7.4.10.2 */
/*@{*/

/// GET_STREAM_FORMAT Response - Clause 7.4.10.2
struct jdksavdecc_aem_command_get_stream_format_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 stream_format;
};

/**
 * Extract the jdksavdecc_aem_command_get_stream_format_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_stream_format_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_format_response_read(
    struct jdksavdecc_aem_command_get_stream_format_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_stream_format_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_stream_format_response_get_descriptor_index(base, pos);
        p->stream_format = jdksavdecc_aem_command_get_stream_format_response_get_stream_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_stream_format_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_stream_format_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_format_response_write(
    struct jdksavdecc_aem_command_get_stream_format_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_stream_format_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_stream_format_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_stream_format_response_set_stream_format(p->stream_format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_video_format SET_VIDEO_FORMAT Command - Clause 7.4.11.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_video_format_get_controller_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_video_format_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_VIDEO_FORMAT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the format_specific field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t format_specific value
 */
static inline uint32_t jdksavdecc_aem_command_set_video_format_get_format_specific(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_FORMAT_SPECIFIC);
}

/**
 * Store a uint32 value to the format_specific field of the
 *COMMAND_SET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t format_specific value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_format_specific(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_FORMAT_SPECIFIC);
}

/**
 * Extract the uint16 value of the aspect_ratio field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t aspect_ratio value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_get_aspect_ratio(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_ASPECT_RATIO);
}

/**
 * Store a uint16 value to the aspect_ratio field of the
 *COMMAND_SET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t aspect_ratio value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_aspect_ratio(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_ASPECT_RATIO);
}

/**
 * Extract the uint16 value of the color_space field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t color_space value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_get_color_space(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_COLOR_SPACE);
}

/**
 * Store a uint16 value to the color_space field of the COMMAND_SET_VIDEO_FORMAT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t color_space value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_color_space(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_COLOR_SPACE);
}

/**
 * Extract the uint32 value of the frame_size field of the
 *COMMAND_SET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frame_size value
 */
static inline uint32_t jdksavdecc_aem_command_set_video_format_get_frame_size(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_FRAME_SIZE);
}

/**
 * Store a uint32 value to the frame_size field of the COMMAND_SET_VIDEO_FORMAT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frame_size value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_set_frame_size(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_OFFSET_FRAME_SIZE);
}

/*@}*/

/** \addtogroup command_set_video_format SET_VIDEO_FORMAT Command - Clause 7.4.11.1 */
/*@{*/

/// SET_VIDEO_FORMAT Command - Clause 7.4.11.1
struct jdksavdecc_aem_command_set_video_format {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t format_specific;
    uint16_t aspect_ratio;
    uint16_t color_space;
    uint32_t frame_size;
};

/**
 * Extract the jdksavdecc_aem_command_set_video_format structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_video_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_video_format_read(struct jdksavdecc_aem_command_set_video_format *p,
                                                                   void const *base,
                                                                   ssize_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_video_format_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_video_format_get_descriptor_index(base, pos);
        p->format_specific = jdksavdecc_aem_command_set_video_format_get_format_specific(base, pos);
        p->aspect_ratio = jdksavdecc_aem_command_set_video_format_get_aspect_ratio(base, pos);
        p->color_space = jdksavdecc_aem_command_set_video_format_get_color_space(base, pos);
        p->frame_size = jdksavdecc_aem_command_set_video_format_get_frame_size(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_video_format structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_video_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_video_format_write(struct jdksavdecc_aem_command_set_video_format const *p,
                                                                    void *base,
                                                                    size_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_video_format_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_video_format_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_video_format_set_format_specific(p->format_specific, base, pos);
        jdksavdecc_aem_command_set_video_format_set_aspect_ratio(p->aspect_ratio, base, pos);
        jdksavdecc_aem_command_set_video_format_set_color_space(p->color_space, base, pos);
        jdksavdecc_aem_command_set_video_format_set_frame_size(p->frame_size, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_video_format_response SET_VIDEO_FORMAT Response -
 * Clause 7.4.11.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_video_format_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_video_format_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the format_specific field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t format_specific value
 */
static inline uint32_t jdksavdecc_aem_command_set_video_format_response_get_format_specific(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_FORMAT_SPECIFIC);
}

/**
 * Store a uint32 value to the format_specific field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t format_specific value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_format_specific(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_FORMAT_SPECIFIC);
}

/**
 * Extract the uint16 value of the aspect_ratio field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t aspect_ratio value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_response_get_aspect_ratio(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_ASPECT_RATIO);
}

/**
 * Store a uint16 value to the aspect_ratio field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t aspect_ratio value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_aspect_ratio(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_ASPECT_RATIO);
}

/**
 * Extract the uint16 value of the color_space field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t color_space value
 */
static inline uint16_t jdksavdecc_aem_command_set_video_format_response_get_color_space(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_COLOR_SPACE);
}

/**
 * Store a uint16 value to the color_space field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t color_space value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_color_space(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_COLOR_SPACE);
}

/**
 * Extract the uint32 value of the frame_size field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frame_size value
 */
static inline uint32_t jdksavdecc_aem_command_set_video_format_response_get_frame_size(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_FRAME_SIZE);
}

/**
 * Store a uint32 value to the frame_size field of the
 *COMMAND_SET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frame_size value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_video_format_response_set_frame_size(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_OFFSET_FRAME_SIZE);
}

/*@}*/

/** \addtogroup command_set_video_format_response SET_VIDEO_FORMAT Response -
 * Clause 7.4.11.1 */
/*@{*/

/// SET_VIDEO_FORMAT Response - Clause 7.4.11.1
struct jdksavdecc_aem_command_set_video_format_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t format_specific;
    uint16_t aspect_ratio;
    uint16_t color_space;
    uint32_t frame_size;
};

/**
 * Extract the jdksavdecc_aem_command_set_video_format_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_video_format_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_video_format_response_read(
    struct jdksavdecc_aem_command_set_video_format_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_video_format_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_video_format_response_get_descriptor_index(base, pos);
        p->format_specific = jdksavdecc_aem_command_set_video_format_response_get_format_specific(base, pos);
        p->aspect_ratio = jdksavdecc_aem_command_set_video_format_response_get_aspect_ratio(base, pos);
        p->color_space = jdksavdecc_aem_command_set_video_format_response_get_color_space(base, pos);
        p->frame_size = jdksavdecc_aem_command_set_video_format_response_get_frame_size(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_video_format_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_video_format_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_video_format_response_write(
    struct jdksavdecc_aem_command_set_video_format_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_VIDEO_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_video_format_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_video_format_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_video_format_response_set_format_specific(p->format_specific, base, pos);
        jdksavdecc_aem_command_set_video_format_response_set_aspect_ratio(p->aspect_ratio, base, pos);
        jdksavdecc_aem_command_set_video_format_response_set_color_space(p->color_space, base, pos);
        jdksavdecc_aem_command_set_video_format_response_set_frame_size(p->frame_size, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_video_format GET_VIDEO_FORMAT Command - Clause 7.4.12.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_video_format_get_controller_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_video_format_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_VIDEO_FORMAT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_VIDEO_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_VIDEO_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_video_format GET_VIDEO_FORMAT Command - Clause 7.4.12.1 */
/*@{*/

/// GET_VIDEO_FORMAT Command - Clause 7.4.12.1
struct jdksavdecc_aem_command_get_video_format {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_video_format structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_video_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_format_read(struct jdksavdecc_aem_command_get_video_format *p,
                                                                   void const *base,
                                                                   ssize_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_video_format_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_video_format_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_video_format structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_video_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_format_write(struct jdksavdecc_aem_command_get_video_format const *p,
                                                                    void *base,
                                                                    size_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_video_format_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_video_format_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_video_format_response GET_VIDEO_FORMAT Response -
 * Clause 7.4.12.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_video_format_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_video_format_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the format_specific field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t format_specific value
 */
static inline uint32_t jdksavdecc_aem_command_get_video_format_response_get_format_specific(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_FORMAT_SPECIFIC);
}

/**
 * Store a uint32 value to the format_specific field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t format_specific value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_format_specific(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_FORMAT_SPECIFIC);
}

/**
 * Extract the uint16 value of the aspect_ratio field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t aspect_ratio value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_response_get_aspect_ratio(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_ASPECT_RATIO);
}

/**
 * Store a uint16 value to the aspect_ratio field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t aspect_ratio value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_aspect_ratio(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_ASPECT_RATIO);
}

/**
 * Extract the uint16 value of the color_space field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t color_space value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_format_response_get_color_space(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_COLOR_SPACE);
}

/**
 * Store a uint16 value to the color_space field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t color_space value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_color_space(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_COLOR_SPACE);
}

/**
 * Extract the uint32 value of the frame_size field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frame_size value
 */
static inline uint32_t jdksavdecc_aem_command_get_video_format_response_get_frame_size(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_FRAME_SIZE);
}

/**
 * Store a uint32 value to the frame_size field of the
 *COMMAND_GET_VIDEO_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frame_size value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_format_response_set_frame_size(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_OFFSET_FRAME_SIZE);
}

/*@}*/

/** \addtogroup command_get_video_format_response GET_VIDEO_FORMAT Response -
 * Clause 7.4.12.2 */
/*@{*/

/// GET_VIDEO_FORMAT Response - Clause 7.4.12.2
struct jdksavdecc_aem_command_get_video_format_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t format_specific;
    uint16_t aspect_ratio;
    uint16_t color_space;
    uint32_t frame_size;
};

/**
 * Extract the jdksavdecc_aem_command_get_video_format_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_video_format_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_format_response_read(
    struct jdksavdecc_aem_command_get_video_format_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_video_format_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_video_format_response_get_descriptor_index(base, pos);
        p->format_specific = jdksavdecc_aem_command_get_video_format_response_get_format_specific(base, pos);
        p->aspect_ratio = jdksavdecc_aem_command_get_video_format_response_get_aspect_ratio(base, pos);
        p->color_space = jdksavdecc_aem_command_get_video_format_response_get_color_space(base, pos);
        p->frame_size = jdksavdecc_aem_command_get_video_format_response_get_frame_size(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_video_format_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_video_format_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_format_response_write(
    struct jdksavdecc_aem_command_get_video_format_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_video_format_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_video_format_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_video_format_response_set_format_specific(p->format_specific, base, pos);
        jdksavdecc_aem_command_get_video_format_response_set_aspect_ratio(p->aspect_ratio, base, pos);
        jdksavdecc_aem_command_get_video_format_response_set_color_space(p->color_space, base, pos);
        jdksavdecc_aem_command_get_video_format_response_set_frame_size(p->frame_size, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_sensor_format SET_SENSOR_FORMAT Command - Clause 7.4.13.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_sensor_format_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_sensor_format_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the sensor_format field of the
 *COMMAND_SET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 sensor_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_sensor_format_get_sensor_format(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_SENSOR_FORMAT);
}

/**
 * Store a eui64 value to the sensor_format field of the
 *COMMAND_SET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 sensor_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_sensor_format_set_sensor_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_OFFSET_SENSOR_FORMAT);
}

/*@}*/

/** \addtogroup command_set_sensor_format SET_SENSOR_FORMAT Command - Clause 7.4.13.1 */
/*@{*/

/// SET_SENSOR_FORMAT Command - Clause 7.4.13.1
struct jdksavdecc_aem_command_set_sensor_format {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 sensor_format;
};

/**
 * Extract the jdksavdecc_aem_command_set_sensor_format structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_sensor_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sensor_format_read(struct jdksavdecc_aem_command_set_sensor_format *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_sensor_format_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_sensor_format_get_descriptor_index(base, pos);
        p->sensor_format = jdksavdecc_aem_command_set_sensor_format_get_sensor_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_sensor_format structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_sensor_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sensor_format_write(struct jdksavdecc_aem_command_set_sensor_format const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_sensor_format_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_sensor_format_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_sensor_format_set_sensor_format(p->sensor_format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_sensor_format_response SET_SENSOR_FORMAT Response -
 * Clause 7.4.13.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_sensor_format_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_sensor_format_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_sensor_format_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sensor_format_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the sensor_format field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 sensor_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_sensor_format_response_get_sensor_format(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_SENSOR_FORMAT);
}

/**
 * Store a eui64 value to the sensor_format field of the
 *COMMAND_SET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 sensor_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_sensor_format_response_set_sensor_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_OFFSET_SENSOR_FORMAT);
}

/*@}*/

/** \addtogroup command_set_sensor_format_response SET_SENSOR_FORMAT Response -
 * Clause 7.4.13.1 */
/*@{*/

/// SET_SENSOR_FORMAT Response - Clause 7.4.13.1
struct jdksavdecc_aem_command_set_sensor_format_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 sensor_format;
};

/**
 * Extract the jdksavdecc_aem_command_set_sensor_format_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_sensor_format_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sensor_format_response_read(
    struct jdksavdecc_aem_command_set_sensor_format_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_sensor_format_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_sensor_format_response_get_descriptor_index(base, pos);
        p->sensor_format = jdksavdecc_aem_command_set_sensor_format_response_get_sensor_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_sensor_format_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_sensor_format_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sensor_format_response_write(
    struct jdksavdecc_aem_command_set_sensor_format_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SENSOR_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_sensor_format_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_sensor_format_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_sensor_format_response_set_sensor_format(p->sensor_format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_sensor_format GET_SENSOR_FORMAT Command - Clause 7.4.14.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_sensor_format_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sensor_format_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SENSOR_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SENSOR_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_sensor_format GET_SENSOR_FORMAT Command - Clause 7.4.14.1 */
/*@{*/

/// GET_SENSOR_FORMAT Command - Clause 7.4.14.1
struct jdksavdecc_aem_command_get_sensor_format {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_sensor_format structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_sensor_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_format_read(struct jdksavdecc_aem_command_get_sensor_format *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_sensor_format_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_sensor_format_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_sensor_format structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_sensor_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_format_write(struct jdksavdecc_aem_command_get_sensor_format const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_sensor_format_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_sensor_format_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_sensor_format_response GET_SENSOR_FORMAT Response -
 * Clause 7.4.14.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_sensor_format_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sensor_format_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_format_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_format_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the sensor_format field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 sensor_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_sensor_format_response_get_sensor_format(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_SENSOR_FORMAT);
}

/**
 * Store a eui64 value to the sensor_format field of the
 *COMMAND_GET_SENSOR_FORMAT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 sensor_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sensor_format_response_set_sensor_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_OFFSET_SENSOR_FORMAT);
}

/*@}*/

/** \addtogroup command_get_sensor_format_response GET_SENSOR_FORMAT Response -
 * Clause 7.4.14.2 */
/*@{*/

/// GET_SENSOR_FORMAT Response - Clause 7.4.14.2
struct jdksavdecc_aem_command_get_sensor_format_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 sensor_format;
};

/**
 * Extract the jdksavdecc_aem_command_get_sensor_format_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_sensor_format_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_format_response_read(
    struct jdksavdecc_aem_command_get_sensor_format_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_sensor_format_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_sensor_format_response_get_descriptor_index(base, pos);
        p->sensor_format = jdksavdecc_aem_command_get_sensor_format_response_get_sensor_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_sensor_format_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_sensor_format_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_format_response_write(
    struct jdksavdecc_aem_command_get_sensor_format_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_FORMAT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_sensor_format_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_sensor_format_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_sensor_format_response_set_sensor_format(p->sensor_format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_stream_info SET_STREAM_INFO Command - Clause 7.4.15.1 */
/*@{*/

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CLASS_B_BIT (31)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CLASS_B (0x00000001)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CLASS_B_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CLASS_B)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_FAST_CONNECT_BIT (30)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_FAST_CONNECT (0x00000002)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_FAST_CONNECT_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_FAST_CONNECT)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_SAVED_STATE_BIT (29)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_SAVED_STATE (0x00000004)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_SAVED_STATE_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_SAVED_STATE)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAMING_WAIT_BIT (28)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAMING_WAIT (0x00000008)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAMING_WAIT_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAMING_WAIT)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_ENCRYPTED_PDU_BIT (27)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_ENCRYPTED_PDU (0x00000010)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_ENCRYPTED_PDU_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_ENCRYPTED_PDU)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_VLAN_ID_VALID_BIT (6)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_VLAN_ID_VALID (0x02000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_VLAN_ID_VALID_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_VLAN_ID_VALID)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CONNECTED_BIT (5)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CONNECTED (0x04000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CONNECTED_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_CONNECTED)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_FAILURE_VALID_BIT (4)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_FAILURE_VALID (0x08000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_FAILURE_VALID_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_FAILURE_VALID)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_DEST_MAC_VALID_BIT (3)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_DEST_MAC_VALID (0x10000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_DEST_MAC_VALID_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_DEST_MAC_VALID)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_ACC_LAT_VALID_BIT (2)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_ACC_LAT_VALID (0x20000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_ACC_LAT_VALID_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_MSRP_ACC_LAT_VALID)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_ID_VALID_BIT (1)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_ID_VALID (0x40000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_ID_VALID_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_ID_VALID)

#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_FORMAT_VALID_BIT (0)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_FORMAT_VALID (0x80000000)
#define JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_FORMAT_VALID_MASK (~JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_FLAG_STREAM_FORMAT_VALID)

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_SET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the aem_stream_info_flags field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_stream_info_flags value
 */
static inline uint32_t jdksavdecc_aem_command_set_stream_info_get_aem_stream_info_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_AEM_STREAM_INFO_FLAGS);
}

/**
 * Store a uint32 value to the aem_stream_info_flags field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_stream_info_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_aem_stream_info_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_AEM_STREAM_INFO_FLAGS);
}

/**
 * Extract the eui64 value of the stream_format field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_get_stream_format(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_FORMAT);
}

/**
 * Store a eui64 value to the stream_format field of the COMMAND_SET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_set_stream_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_FORMAT);
}

/**
 * Extract the eui64 value of the stream_id field of the COMMAND_SET_STREAM_INFO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_get_stream_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_ID);
}

/**
 * Store a eui64 value to the stream_id field of the COMMAND_SET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_stream_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_ID);
}

/**
 * Extract the uint32 value of the msrp_accumulated_latency field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t msrp_accumulated_latency value
 */
static inline uint32_t jdksavdecc_aem_command_set_stream_info_get_msrp_accumulated_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_ACCUMULATED_LATENCY);
}

/**
 * Store a uint32 value to the msrp_accumulated_latency field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t msrp_accumulated_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_msrp_accumulated_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_ACCUMULATED_LATENCY);
}

/**
 * Extract the eui48 value of the stream_dest_mac field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui48 stream_dest_mac value
 */
static inline struct jdksavdecc_eui48 jdksavdecc_aem_command_set_stream_info_get_stream_dest_mac(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui48_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_DEST_MAC);
}

/**
 * Store a eui48 value to the stream_dest_mac field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui48 stream_dest_mac value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_set_stream_dest_mac(struct jdksavdecc_eui48 v, void *base, ssize_t pos) {
    jdksavdecc_eui48_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_DEST_MAC);
}

/**
 * Extract the uint8 value of the msrp_failure_code field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t msrp_failure_code value
 */
static inline uint8_t jdksavdecc_aem_command_set_stream_info_get_msrp_failure_code(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_FAILURE_CODE);
}

/**
 * Store a uint8 value to the msrp_failure_code field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t msrp_failure_code value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_msrp_failure_code(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_FAILURE_CODE);
}

/**
 * Extract the uint8 value of the reserved field of the COMMAND_SET_STREAM_INFO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t reserved value
 */
static inline uint8_t jdksavdecc_aem_command_set_stream_info_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint8 value to the reserved field of the COMMAND_SET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_reserved(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the msrp_failure_bridge_id field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 msrp_failure_bridge_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_get_msrp_failure_bridge_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_FAILURE_BRIDGE_ID);
}

/**
 * Store a eui64 value to the msrp_failure_bridge_id field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 msrp_failure_bridge_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_set_msrp_failure_bridge_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_MSRP_FAILURE_BRIDGE_ID);
}


/**
 * Extract the uint16 value of the stream_vlan_id field of the
 *COMMAND_SET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t stream_vlan_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_get_stream_vlan_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_VLAN_ID);
}

/**
 * Store a uint16_t value to the stream_vlan_id field of the
 *COMMAND_SET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t stream_vlan_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_set_stream_vlan_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_VLAN_ID);
}


/**
 * Extract the uint16_t value of the reserved2 field of the COMMAND_SET_STREAM_INFO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved2 value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_get_reserved2(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED2);
}

/**
 * Store a uint16_t value to the reserved2 field of the COMMAND_SET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved2 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_set_reserved2(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED2);
}

/*@}*/

/** \addtogroup command_set_stream_info SET_STREAM_INFO Command - Clause 7.4.15.1 */
/*@{*/

/// SET_STREAM_INFO Command - Clause 7.4.15.1
struct jdksavdecc_aem_command_set_stream_info {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t aem_stream_info_flags;
    struct jdksavdecc_eui64 stream_format;
    struct jdksavdecc_eui64 stream_id;
    uint32_t msrp_accumulated_latency;
    struct jdksavdecc_eui48 stream_dest_mac;
    uint8_t msrp_failure_code;
    uint8_t reserved;
    struct jdksavdecc_eui64 msrp_failure_bridge_id;
    uint16_t stream_vlan_id;
    uint16_t reserved2;
};

/**
 * Extract the jdksavdecc_aem_command_set_stream_info structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_stream_info structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_info_read(struct jdksavdecc_aem_command_set_stream_info *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_stream_info_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_stream_info_get_descriptor_index(base, pos);
        p->aem_stream_info_flags = jdksavdecc_aem_command_set_stream_info_get_aem_stream_info_flags(base, pos);
        p->stream_format = jdksavdecc_aem_command_set_stream_info_get_stream_format(base, pos);
        p->stream_id = jdksavdecc_aem_command_set_stream_info_get_stream_id(base, pos);
        p->msrp_accumulated_latency = jdksavdecc_aem_command_set_stream_info_get_msrp_accumulated_latency(base, pos);
        p->stream_dest_mac = jdksavdecc_aem_command_set_stream_info_get_stream_dest_mac(base, pos);
        p->msrp_failure_code = jdksavdecc_aem_command_set_stream_info_get_msrp_failure_code(base, pos);
        p->reserved = jdksavdecc_aem_command_set_stream_info_get_reserved(base, pos);
        p->msrp_failure_bridge_id = jdksavdecc_aem_command_set_stream_info_get_msrp_failure_bridge_id(base, pos);
        p->stream_vlan_id = jdksavdecc_aem_command_set_stream_info_get_stream_vlan_id(base, pos);
        p->reserved2 = jdksavdecc_aem_command_set_stream_info_get_reserved2(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_stream_info structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_stream_info structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_info_write(struct jdksavdecc_aem_command_set_stream_info const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_stream_info_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_aem_stream_info_flags(p->aem_stream_info_flags, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_stream_format(p->stream_format, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_stream_id(p->stream_id, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_msrp_accumulated_latency(p->msrp_accumulated_latency, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_stream_dest_mac(p->stream_dest_mac, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_msrp_failure_code(p->msrp_failure_code, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_msrp_failure_bridge_id(p->msrp_failure_bridge_id, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_stream_vlan_id(p->stream_vlan_id, base, pos);
        jdksavdecc_aem_command_set_stream_info_set_reserved2(p->reserved2, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_stream_info_response SET_STREAM_INFO Response -
 * Clause 7.4.15.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_stream_info_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the aem_stream_info_flags field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_stream_info_flags value
 */
static inline uint32_t jdksavdecc_aem_command_set_stream_info_response_get_aem_stream_info_flags(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_AEM_STREAM_INFO_FLAGS);
}

/**
 * Store a uint32 value to the aem_stream_info_flags field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_stream_info_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_aem_stream_info_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_AEM_STREAM_INFO_FLAGS);
}

/**
 * Extract the eui64 value of the stream_format field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_response_get_stream_format(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_FORMAT);
}

/**
 * Store a eui64 value to the stream_format field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_stream_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_FORMAT);
}

/**
 * Extract the eui64 value of the stream_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_stream_info_response_get_stream_id(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_ID);
}

/**
 * Store a eui64 value to the stream_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_stream_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_ID);
}

/**
 * Extract the uint32 value of the msrp_accumulated_latency field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t msrp_accumulated_latency value
 */
static inline uint32_t jdksavdecc_aem_command_set_stream_info_response_get_msrp_accumulated_latency(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_ACCUMULATED_LATENCY);
}

/**
 * Store a uint32 value to the msrp_accumulated_latency field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t msrp_accumulated_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_msrp_accumulated_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_ACCUMULATED_LATENCY);
}

/**
 * Extract the eui48 value of the stream_dest_mac field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui48 stream_dest_mac value
 */
static inline struct jdksavdecc_eui48 jdksavdecc_aem_command_set_stream_info_response_get_stream_dest_mac(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui48_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_DEST_MAC);
}

/**
 * Store a eui48 value to the stream_dest_mac field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui48 stream_dest_mac value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_stream_dest_mac(struct jdksavdecc_eui48 v, void *base, ssize_t pos) {
    jdksavdecc_eui48_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_STREAM_DEST_MAC);
}

/**
 * Extract the uint8 value of the msrp_failure_code field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t msrp_failure_code value
 */
static inline uint8_t jdksavdecc_aem_command_set_stream_info_response_get_msrp_failure_code(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_CODE);
}

/**
 * Store a uint8 value to the msrp_failure_code field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t msrp_failure_code value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_response_set_msrp_failure_code(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_CODE);
}

/**
 * Extract the uint8 value of the reserved field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t reserved value
 */
static inline uint8_t jdksavdecc_aem_command_set_stream_info_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint8 value to the reserved field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_stream_info_response_set_reserved(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the msrp_failure_bridge_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 msrp_failure_bridge_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_stream_info_response_get_msrp_failure_bridge_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_BRIDGE_ID);
}

/**
 * Store a eui64 value to the msrp_failure_bridge_id field of the
 *COMMAND_SET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 msrp_failure_bridge_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_stream_info_response_set_msrp_failure_bridge_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_BRIDGE_ID);
}

/*@}*/

/** \addtogroup command_set_stream_info_response SET_STREAM_INFO Response -
 * Clause 7.4.15.1 */
/*@{*/

/// SET_STREAM_INFO Response - Clause 7.4.15.1
struct jdksavdecc_aem_command_set_stream_info_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t aem_stream_info_flags;
    struct jdksavdecc_eui64 stream_format;
    struct jdksavdecc_eui64 stream_id;
    uint32_t msrp_accumulated_latency;
    struct jdksavdecc_eui48 stream_dest_mac;
    uint8_t msrp_failure_code;
    uint8_t reserved;
    struct jdksavdecc_eui64 msrp_failure_bridge_id;
};

/**
 * Extract the jdksavdecc_aem_command_set_stream_info_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_stream_info_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_info_response_read(
    struct jdksavdecc_aem_command_set_stream_info_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_stream_info_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_stream_info_response_get_descriptor_index(base, pos);
        p->aem_stream_info_flags = jdksavdecc_aem_command_set_stream_info_response_get_aem_stream_info_flags(base, pos);
        p->stream_format = jdksavdecc_aem_command_set_stream_info_response_get_stream_format(base, pos);
        p->stream_id = jdksavdecc_aem_command_set_stream_info_response_get_stream_id(base, pos);
        p->msrp_accumulated_latency = jdksavdecc_aem_command_set_stream_info_response_get_msrp_accumulated_latency(base, pos);
        p->stream_dest_mac = jdksavdecc_aem_command_set_stream_info_response_get_stream_dest_mac(base, pos);
        p->msrp_failure_code = jdksavdecc_aem_command_set_stream_info_response_get_msrp_failure_code(base, pos);
        p->reserved = jdksavdecc_aem_command_set_stream_info_response_get_reserved(base, pos);
        p->msrp_failure_bridge_id = jdksavdecc_aem_command_set_stream_info_response_get_msrp_failure_bridge_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_stream_info_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_stream_info_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_stream_info_response_write(
    struct jdksavdecc_aem_command_set_stream_info_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_stream_info_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_aem_stream_info_flags(p->aem_stream_info_flags, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_stream_format(p->stream_format, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_stream_id(p->stream_id, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_msrp_accumulated_latency(p->msrp_accumulated_latency, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_stream_dest_mac(p->stream_dest_mac, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_msrp_failure_code(p->msrp_failure_code, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_set_stream_info_response_set_msrp_failure_bridge_id(p->msrp_failure_bridge_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_stream_info GET_STREAM_INFO Command - Clause 7.4.16.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_stream_info_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_STREAM_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_STREAM_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_STREAM_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_stream_info GET_STREAM_INFO Command - Clause 7.4.16.1 */
/*@{*/

/// GET_STREAM_INFO Command - Clause 7.4.16.1
struct jdksavdecc_aem_command_get_stream_info {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_stream_info structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_stream_info structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_info_read(struct jdksavdecc_aem_command_get_stream_info *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_stream_info_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_stream_info_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_stream_info structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_stream_info structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_info_write(struct jdksavdecc_aem_command_get_stream_info const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_stream_info_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_stream_info_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_stream_info_response GET_STREAM_INFO Response -
 * Clause 7.4.16.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_stream_info_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the aem_stream_info_flags field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t aem_stream_info_flags value
 */
static inline uint32_t jdksavdecc_aem_command_get_stream_info_response_get_aem_stream_info_flags(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_AEM_STREAM_INFO_FLAGS);
}

/**
 * Store a uint32 value to the aem_stream_info_flags field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t aem_stream_info_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_aem_stream_info_flags(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_AEM_STREAM_INFO_FLAGS);
}

/**
 * Extract the eui64 value of the stream_format field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_stream_info_response_get_stream_format(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_FORMAT);
}

/**
 * Store a eui64 value to the stream_format field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_stream_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_FORMAT);
}

/**
 * Extract the eui64 value of the stream_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 stream_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_stream_info_response_get_stream_id(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_ID);
}

/**
 * Store a eui64 value to the stream_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 stream_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_stream_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_ID);
}

/**
 * Extract the uint32 value of the msrp_accumulated_latency field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t msrp_accumulated_latency value
 */
static inline uint32_t jdksavdecc_aem_command_get_stream_info_response_get_msrp_accumulated_latency(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_ACCUMULATED_LATENCY);
}

/**
 * Store a uint32 value to the msrp_accumulated_latency field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t msrp_accumulated_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_msrp_accumulated_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_ACCUMULATED_LATENCY);
}

/**
 * Extract the eui48 value of the stream_dest_mac field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui48 stream_dest_mac value
 */
static inline struct jdksavdecc_eui48 jdksavdecc_aem_command_get_stream_info_response_get_stream_dest_mac(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui48_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_DEST_MAC);
}

/**
 * Store a eui48 value to the stream_dest_mac field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui48 stream_dest_mac value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_stream_dest_mac(struct jdksavdecc_eui48 v, void *base, ssize_t pos) {
    jdksavdecc_eui48_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_STREAM_DEST_MAC);
}

/**
 * Extract the uint8 value of the msrp_failure_code field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t msrp_failure_code value
 */
static inline uint8_t jdksavdecc_aem_command_get_stream_info_response_get_msrp_failure_code(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_CODE);
}

/**
 * Store a uint8 value to the msrp_failure_code field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t msrp_failure_code value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_msrp_failure_code(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_CODE);
}

/**
 * Extract the uint8 value of the reserved field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t reserved value
 */
static inline uint8_t jdksavdecc_aem_command_get_stream_info_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint8 value to the reserved field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_reserved(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the msrp_failure_bridge_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 msrp_failure_bridge_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_stream_info_response_get_msrp_failure_bridge_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_BRIDGE_ID);
}

/**
 * Store a eui64 value to the msrp_failure_bridge_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 msrp_failure_bridge_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_msrp_failure_bridge_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_OFFSET_MSRP_FAILURE_BRIDGE_ID);
}


/**
 * Extract the uint16 value of the stream_vlan_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t stream_vlan_id value
 */
static inline uint16_t
jdksavdecc_aem_command_get_stream_info_response_get_stream_vlan_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_VLAN_ID);
}

/**
 * Store a uint16_t value to the stream_vlan_id field of the
 *COMMAND_GET_STREAM_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t stream_vlan_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_stream_info_response_set_stream_vlan_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_STREAM_VLAN_ID);
}


/**
 * Extract the uint16_t value of the reserved2 field of the COMMAND_GET_STREAM_INFO_RESPONSE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved2 value
 */
static inline uint16_t jdksavdecc_aem_command_get_stream_info_response_get_reserved2(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED2);
}

/**
 * Store a uint16_t value to the reserved2 field of the COMMAND_GET_STREAM_INFO_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved2 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_stream_info_response_set_reserved2(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_STREAM_INFO_COMMAND_OFFSET_RESERVED2);
}

/*@}*/

/** \addtogroup command_get_stream_info_response GET_STREAM_INFO Response -
 * Clause 7.4.16.2 */
/*@{*/

/// GET_STREAM_INFO Response - Clause 7.4.16.2
struct jdksavdecc_aem_command_get_stream_info_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t aem_stream_info_flags;
    struct jdksavdecc_eui64 stream_format;
    struct jdksavdecc_eui64 stream_id;
    uint32_t msrp_accumulated_latency;
    struct jdksavdecc_eui48 stream_dest_mac;
    uint8_t msrp_failure_code;
    uint8_t reserved;
    struct jdksavdecc_eui64 msrp_failure_bridge_id;
    uint16_t stream_vlan_id;
    uint16_t reserved2;
};

/**
 * Extract the jdksavdecc_aem_command_get_stream_info_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_stream_info_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_info_response_read(
    struct jdksavdecc_aem_command_get_stream_info_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_stream_info_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_stream_info_response_get_descriptor_index(base, pos);
        p->aem_stream_info_flags = jdksavdecc_aem_command_get_stream_info_response_get_aem_stream_info_flags(base, pos);
        p->stream_format = jdksavdecc_aem_command_get_stream_info_response_get_stream_format(base, pos);
        p->stream_id = jdksavdecc_aem_command_get_stream_info_response_get_stream_id(base, pos);
        p->msrp_accumulated_latency = jdksavdecc_aem_command_get_stream_info_response_get_msrp_accumulated_latency(base, pos);
        p->stream_dest_mac = jdksavdecc_aem_command_get_stream_info_response_get_stream_dest_mac(base, pos);
        p->msrp_failure_code = jdksavdecc_aem_command_get_stream_info_response_get_msrp_failure_code(base, pos);
        p->reserved = jdksavdecc_aem_command_get_stream_info_response_get_reserved(base, pos);
        p->msrp_failure_bridge_id = jdksavdecc_aem_command_get_stream_info_response_get_msrp_failure_bridge_id(base, pos);
        p->stream_vlan_id = jdksavdecc_aem_command_get_stream_info_response_get_stream_vlan_id(base, pos);
        p->reserved2 = jdksavdecc_aem_command_get_stream_info_response_get_reserved2(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_stream_info_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_stream_info_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_stream_info_response_write(
    struct jdksavdecc_aem_command_get_stream_info_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_STREAM_INFO_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_stream_info_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_aem_stream_info_flags(p->aem_stream_info_flags, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_stream_format(p->stream_format, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_stream_id(p->stream_id, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_msrp_accumulated_latency(p->msrp_accumulated_latency, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_stream_dest_mac(p->stream_dest_mac, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_msrp_failure_code(p->msrp_failure_code, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_msrp_failure_bridge_id(p->msrp_failure_bridge_id, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_stream_vlan_id(p->stream_vlan_id, base, pos);
        jdksavdecc_aem_command_get_stream_info_response_set_reserved2(p->reserved2, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_name SET_NAME Command - Clause 7.4.17.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_NAME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_name_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the COMMAND_SET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_name_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_SET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_NAME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_SET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_SET_NAME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the COMMAND_SET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_SET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_NAME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_SET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the name_index field of the COMMAND_SET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t name_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_get_name_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_NAME_INDEX);
}

/**
 * Store a uint16 value to the name_index field of the COMMAND_SET_NAME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t name_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_name_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_NAME_INDEX);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_SET_NAME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the COMMAND_SET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the string value of the name field of the COMMAND_SET_NAME object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string name value
 */
static inline struct jdksavdecc_string jdksavdecc_aem_command_set_name_get_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_NAME);
}

/**
 * Store a string value to the name field of the COMMAND_SET_NAME object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_set_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_OFFSET_NAME);
}

/*@}*/

/** \addtogroup command_set_name SET_NAME Command - Clause 7.4.17.1 */
/*@{*/

/// SET_NAME Command - Clause 7.4.17.1
struct jdksavdecc_aem_command_set_name {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t name_index;
    uint16_t configuration_index;
    struct jdksavdecc_string name;
};

/**
 * Extract the jdksavdecc_aem_command_set_name structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_name structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_set_name_read(struct jdksavdecc_aem_command_set_name *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_name_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_name_get_descriptor_index(base, pos);
        p->name_index = jdksavdecc_aem_command_set_name_get_name_index(base, pos);
        p->configuration_index = jdksavdecc_aem_command_set_name_get_configuration_index(base, pos);
        p->name = jdksavdecc_aem_command_set_name_get_name(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_name structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_name structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_set_name_write(struct jdksavdecc_aem_command_set_name const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_NAME_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_name_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_name_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_name_set_name_index(p->name_index, base, pos);
        jdksavdecc_aem_command_set_name_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_set_name_set_name(p->name, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_name_response SET_NAME Response - Clause 7.4.17.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_name_response_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_name_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the name_index field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t name_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_response_get_name_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_NAME_INDEX);
}

/**
 * Store a uint16 value to the name_index field of the COMMAND_SET_NAME_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t name_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_name_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_NAME_INDEX);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_SET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_name_response_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_SET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the string value of the name field of the COMMAND_SET_NAME_RESPONSE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string name value
 */
static inline struct jdksavdecc_string jdksavdecc_aem_command_set_name_response_get_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_NAME);
}

/**
 * Store a string value to the name field of the COMMAND_SET_NAME_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_name_response_set_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_OFFSET_NAME);
}

/*@}*/

/** \addtogroup command_set_name_response SET_NAME Response - Clause 7.4.17.1 */
/*@{*/

/// SET_NAME Response - Clause 7.4.17.1
struct jdksavdecc_aem_command_set_name_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t name_index;
    uint16_t configuration_index;
    struct jdksavdecc_string name;
};

/**
 * Extract the jdksavdecc_aem_command_set_name_response structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_name_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_name_response_read(struct jdksavdecc_aem_command_set_name_response *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_name_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_name_response_get_descriptor_index(base, pos);
        p->name_index = jdksavdecc_aem_command_set_name_response_get_name_index(base, pos);
        p->configuration_index = jdksavdecc_aem_command_set_name_response_get_configuration_index(base, pos);
        p->name = jdksavdecc_aem_command_set_name_response_get_name(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_name_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_name_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_name_response_write(struct jdksavdecc_aem_command_set_name_response const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_NAME_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_name_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_name_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_name_response_set_name_index(p->name_index, base, pos);
        jdksavdecc_aem_command_set_name_response_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_set_name_response_set_name(p->name, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_name GET_NAME Command - Clause 7.4.18.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_NAME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_name_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the COMMAND_GET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_name_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_NAME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_GET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_NAME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the COMMAND_GET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_GET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_NAME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_GET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the name_index field of the COMMAND_GET_NAME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t name_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_get_name_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_NAME_INDEX);
}

/**
 * Store a uint16 value to the name_index field of the COMMAND_GET_NAME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t name_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_set_name_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_NAME_INDEX);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_GET_NAME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the COMMAND_GET_NAME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_OFFSET_CONFIGURATION_INDEX);
}

/*@}*/

/** \addtogroup command_get_name GET_NAME Command - Clause 7.4.18.1 */
/*@{*/

/// GET_NAME Command - Clause 7.4.18.1
struct jdksavdecc_aem_command_get_name {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t name_index;
    uint16_t configuration_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_name structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_name structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_get_name_read(struct jdksavdecc_aem_command_get_name *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_name_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_name_get_descriptor_index(base, pos);
        p->name_index = jdksavdecc_aem_command_get_name_get_name_index(base, pos);
        p->configuration_index = jdksavdecc_aem_command_get_name_get_configuration_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_name structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_name structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_get_name_write(struct jdksavdecc_aem_command_get_name const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_NAME_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_name_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_name_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_name_set_name_index(p->name_index, base, pos);
        jdksavdecc_aem_command_get_name_set_configuration_index(p->configuration_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_name_response GET_NAME Response - Clause 7.4.18.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_name_response_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_name_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the name_index field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t name_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_response_get_name_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_NAME_INDEX);
}

/**
 * Store a uint16 value to the name_index field of the COMMAND_GET_NAME_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t name_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_name_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_NAME_INDEX);
}

/**
 * Extract the uint16 value of the configuration_index field of the
 *COMMAND_GET_NAME_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configuration_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_name_response_get_configuration_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Store a uint16 value to the configuration_index field of the
 *COMMAND_GET_NAME_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configuration_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_configuration_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_CONFIGURATION_INDEX);
}

/**
 * Extract the string value of the name field of the COMMAND_GET_NAME_RESPONSE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string name value
 */
static inline struct jdksavdecc_string jdksavdecc_aem_command_get_name_response_get_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_NAME);
}

/**
 * Store a string value to the name field of the COMMAND_GET_NAME_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_name_response_set_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_OFFSET_NAME);
}

/*@}*/

/** \addtogroup command_get_name_response GET_NAME Response - Clause 7.4.18.2 */
/*@{*/

/// GET_NAME Response - Clause 7.4.18.2
struct jdksavdecc_aem_command_get_name_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t name_index;
    uint16_t configuration_index;
    struct jdksavdecc_string name;
};

/**
 * Extract the jdksavdecc_aem_command_get_name_response structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_name_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_name_response_read(struct jdksavdecc_aem_command_get_name_response *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_name_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_name_response_get_descriptor_index(base, pos);
        p->name_index = jdksavdecc_aem_command_get_name_response_get_name_index(base, pos);
        p->configuration_index = jdksavdecc_aem_command_get_name_response_get_configuration_index(base, pos);
        p->name = jdksavdecc_aem_command_get_name_response_get_name(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_name_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_name_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_name_response_write(struct jdksavdecc_aem_command_get_name_response const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_NAME_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_name_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_name_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_name_response_set_name_index(p->name_index, base, pos);
        jdksavdecc_aem_command_get_name_response_set_configuration_index(p->configuration_index, base, pos);
        jdksavdecc_aem_command_get_name_response_set_name(p->name, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_association_id SET_ASSOCIATION_ID Command - Clause 7.4.19.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_association_id_get_controller_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_association_id_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_association_id_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_association_id_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_association_id_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_association_id_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the association_id field of the
 *COMMAND_SET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 association_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_association_id_get_association_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_ASSOCIATION_ID);
}

/**
 * Store a eui64 value to the association_id field of the
 *COMMAND_SET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 association_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_association_id_set_association_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_OFFSET_ASSOCIATION_ID);
}

/*@}*/

/** \addtogroup command_set_association_id SET_ASSOCIATION_ID Command - Clause 7.4.19.1 */
/*@{*/

/// SET_ASSOCIATION_ID Command - Clause 7.4.19.1
struct jdksavdecc_aem_command_set_association_id {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 association_id;
};

/**
 * Extract the jdksavdecc_aem_command_set_association_id structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_association_id structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_association_id_read(struct jdksavdecc_aem_command_set_association_id *p,
                                                                     void const *base,
                                                                     ssize_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->association_id = jdksavdecc_aem_command_set_association_id_get_association_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_association_id structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_association_id structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_association_id_write(struct jdksavdecc_aem_command_set_association_id const *p,
                                                                      void *base,
                                                                      size_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_association_id_set_association_id(p->association_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_association_id_response SET_ASSOCIATION_ID Response
 * - Clause 7.4.19.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_association_id_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_association_id_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                               void *base,
                                                                                               ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_association_id_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_association_id_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_association_id_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_association_id_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the association_id field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 association_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_association_id_response_get_association_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_ASSOCIATION_ID);
}

/**
 * Store a eui64 value to the association_id field of the
 *COMMAND_SET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 association_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_association_id_response_set_association_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_OFFSET_ASSOCIATION_ID);
}

/*@}*/

/** \addtogroup command_set_association_id_response SET_ASSOCIATION_ID Response
 * - Clause 7.4.19.1 */
/*@{*/

/// SET_ASSOCIATION_ID Response - Clause 7.4.19.1
struct jdksavdecc_aem_command_set_association_id_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 association_id;
};

/**
 * Extract the jdksavdecc_aem_command_set_association_id_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_association_id_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_association_id_response_read(
    struct jdksavdecc_aem_command_set_association_id_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->association_id = jdksavdecc_aem_command_set_association_id_response_get_association_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_association_id_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_association_id_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_association_id_response_write(
    struct jdksavdecc_aem_command_set_association_id_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_ASSOCIATION_ID_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_association_id_response_set_association_id(p->association_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_association_id GET_ASSOCIATION_ID Command - Clause 7.4.20.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_association_id_get_controller_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_association_id_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_association_id_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_association_id_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_ASSOCIATION_ID object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_association_id_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_ASSOCIATION_ID object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_association_id_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_get_association_id GET_ASSOCIATION_ID Command - Clause 7.4.20.1 */
/*@{*/

/// GET_ASSOCIATION_ID Command - Clause 7.4.20.1
struct jdksavdecc_aem_command_get_association_id {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_get_association_id structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_association_id structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_association_id_read(struct jdksavdecc_aem_command_get_association_id *p,
                                                                     void const *base,
                                                                     ssize_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_association_id structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_association_id structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_association_id_write(struct jdksavdecc_aem_command_get_association_id const *p,
                                                                      void *base,
                                                                      size_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_association_id_response GET_ASSOCIATION_ID Response
 * - Clause 7.4.20.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_association_id_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_association_id_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                               void *base,
                                                                                               ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_association_id_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_association_id_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_association_id_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_association_id_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the association_id field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 association_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_association_id_response_get_association_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_ASSOCIATION_ID);
}

/**
 * Store a eui64 value to the association_id field of the
 *COMMAND_GET_ASSOCIATION_ID_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 association_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_association_id_response_set_association_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_OFFSET_ASSOCIATION_ID);
}

/*@}*/

/** \addtogroup command_get_association_id_response GET_ASSOCIATION_ID Response
 * - Clause 7.4.20.2 */
/*@{*/

/// GET_ASSOCIATION_ID Response - Clause 7.4.20.2
struct jdksavdecc_aem_command_get_association_id_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 association_id;
};

/**
 * Extract the jdksavdecc_aem_command_get_association_id_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_association_id_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_association_id_response_read(
    struct jdksavdecc_aem_command_get_association_id_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->association_id = jdksavdecc_aem_command_get_association_id_response_get_association_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_association_id_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_association_id_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_association_id_response_write(
    struct jdksavdecc_aem_command_get_association_id_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_ASSOCIATION_ID_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_association_id_response_set_association_id(p->association_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_sampling_rate SET_SAMPLING_RATE Command - Clause 7.4.21.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_sampling_rate_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_sampling_rate_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the sampling_rate field of the
 *COMMAND_SET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t sampling_rate value
 */
static inline uint32_t jdksavdecc_aem_command_set_sampling_rate_get_sampling_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_SAMPLING_RATE);
}

/**
 * Store a uint32 value to the sampling_rate field of the
 *COMMAND_SET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t sampling_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_set_sampling_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_OFFSET_SAMPLING_RATE);
}

/*@}*/

/** \addtogroup command_set_sampling_rate SET_SAMPLING_RATE Command - Clause 7.4.21.1 */
/*@{*/

/// SET_SAMPLING_RATE Command - Clause 7.4.21.1
struct jdksavdecc_aem_command_set_sampling_rate {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t sampling_rate;
};

/**
 * Extract the jdksavdecc_aem_command_set_sampling_rate structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_sampling_rate structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sampling_rate_read(struct jdksavdecc_aem_command_set_sampling_rate *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_sampling_rate_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_sampling_rate_get_descriptor_index(base, pos);
        p->sampling_rate = jdksavdecc_aem_command_set_sampling_rate_get_sampling_rate(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_sampling_rate structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_sampling_rate structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sampling_rate_write(struct jdksavdecc_aem_command_set_sampling_rate const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_sampling_rate_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_sampling_rate_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_sampling_rate_set_sampling_rate(p->sampling_rate, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_sampling_rate_response SET_SAMPLING_RATE Response -
 * Clause 7.4.21.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_sampling_rate_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_sampling_rate_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_sampling_rate_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the sampling_rate field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t sampling_rate value
 */
static inline uint32_t jdksavdecc_aem_command_set_sampling_rate_response_get_sampling_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_SAMPLING_RATE);
}

/**
 * Store a uint32 value to the sampling_rate field of the
 *COMMAND_SET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t sampling_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_sampling_rate_response_set_sampling_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_OFFSET_SAMPLING_RATE);
}

/*@}*/

/** \addtogroup command_set_sampling_rate_response SET_SAMPLING_RATE Response -
 * Clause 7.4.21.1 */
/*@{*/

/// SET_SAMPLING_RATE Response - Clause 7.4.21.1
struct jdksavdecc_aem_command_set_sampling_rate_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t sampling_rate;
};

/**
 * Extract the jdksavdecc_aem_command_set_sampling_rate_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_sampling_rate_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sampling_rate_response_read(
    struct jdksavdecc_aem_command_set_sampling_rate_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_sampling_rate_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_sampling_rate_response_get_descriptor_index(base, pos);
        p->sampling_rate = jdksavdecc_aem_command_set_sampling_rate_response_get_sampling_rate(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_sampling_rate_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_sampling_rate_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_sampling_rate_response_write(
    struct jdksavdecc_aem_command_set_sampling_rate_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SAMPLING_RATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_sampling_rate_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_sampling_rate_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_sampling_rate_response_set_sampling_rate(p->sampling_rate, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_sampling_rate GET_SAMPLING_RATE Command - Clause 7.4.22.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_sampling_rate_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sampling_rate_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SAMPLING_RATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SAMPLING_RATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_sampling_rate GET_SAMPLING_RATE Command - Clause 7.4.22.1 */
/*@{*/

/// GET_SAMPLING_RATE Command - Clause 7.4.22.1
struct jdksavdecc_aem_command_get_sampling_rate {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_sampling_rate structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_sampling_rate structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sampling_rate_read(struct jdksavdecc_aem_command_get_sampling_rate *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_sampling_rate_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_sampling_rate_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_sampling_rate structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_sampling_rate structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sampling_rate_write(struct jdksavdecc_aem_command_get_sampling_rate const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_sampling_rate_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_sampling_rate_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_sampling_rate_response GET_SAMPLING_RATE Response -
 * Clause 7.4.22.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_sampling_rate_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sampling_rate_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sampling_rate_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the sampling_rate field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t sampling_rate value
 */
static inline uint32_t jdksavdecc_aem_command_get_sampling_rate_response_get_sampling_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_SAMPLING_RATE);
}

/**
 * Store a uint32 value to the sampling_rate field of the
 *COMMAND_GET_SAMPLING_RATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t sampling_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sampling_rate_response_set_sampling_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_OFFSET_SAMPLING_RATE);
}

/*@}*/

/** \addtogroup command_get_sampling_rate_response GET_SAMPLING_RATE Response -
 * Clause 7.4.22.2 */
/*@{*/

/// GET_SAMPLING_RATE Response - Clause 7.4.22.2
struct jdksavdecc_aem_command_get_sampling_rate_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t sampling_rate;
};

/**
 * Extract the jdksavdecc_aem_command_get_sampling_rate_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_sampling_rate_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sampling_rate_response_read(
    struct jdksavdecc_aem_command_get_sampling_rate_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_sampling_rate_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_sampling_rate_response_get_descriptor_index(base, pos);
        p->sampling_rate = jdksavdecc_aem_command_get_sampling_rate_response_get_sampling_rate(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_sampling_rate_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_sampling_rate_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sampling_rate_response_write(
    struct jdksavdecc_aem_command_get_sampling_rate_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SAMPLING_RATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_sampling_rate_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_sampling_rate_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_sampling_rate_response_set_sampling_rate(p->sampling_rate, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_clock_source SET_CLOCK_SOURCE Command - Clause 7.4.23.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_clock_source_get_controller_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_clock_source_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_CLOCK_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the clock_source_index field of the
 *COMMAND_SET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_get_clock_source_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_CLOCK_SOURCE_INDEX);
}

/**
 * Store a uint16 value to the clock_source_index field of the
 *COMMAND_SET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_set_clock_source_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_OFFSET_CLOCK_SOURCE_INDEX);
}

/*@}*/

/** \addtogroup command_set_clock_source SET_CLOCK_SOURCE Command - Clause 7.4.23.1 */
/*@{*/

/// SET_CLOCK_SOURCE Command - Clause 7.4.23.1
struct jdksavdecc_aem_command_set_clock_source {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t clock_source_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_clock_source structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_clock_source structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_clock_source_read(struct jdksavdecc_aem_command_set_clock_source *p,
                                                                   void const *base,
                                                                   ssize_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_clock_source_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_clock_source_get_descriptor_index(base, pos);
        p->clock_source_index = jdksavdecc_aem_command_set_clock_source_get_clock_source_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_clock_source structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_clock_source structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_clock_source_write(struct jdksavdecc_aem_command_set_clock_source const *p,
                                                                    void *base,
                                                                    size_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_clock_source_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_clock_source_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_clock_source_set_clock_source_index(p->clock_source_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_clock_source_response SET_CLOCK_SOURCE Response -
 * Clause 7.4.23.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_clock_source_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_clock_source_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_clock_source_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the clock_source_index field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_clock_source_response_get_clock_source_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_CLOCK_SOURCE_INDEX);
}

/**
 * Store a uint16 value to the clock_source_index field of the
 *COMMAND_SET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_clock_source_response_set_clock_source_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_OFFSET_CLOCK_SOURCE_INDEX);
}

/*@}*/

/** \addtogroup command_set_clock_source_response SET_CLOCK_SOURCE Response -
 * Clause 7.4.23.1 */
/*@{*/

/// SET_CLOCK_SOURCE Response - Clause 7.4.23.1
struct jdksavdecc_aem_command_set_clock_source_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t clock_source_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_clock_source_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_clock_source_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_clock_source_response_read(
    struct jdksavdecc_aem_command_set_clock_source_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_clock_source_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_clock_source_response_get_descriptor_index(base, pos);
        p->clock_source_index = jdksavdecc_aem_command_set_clock_source_response_get_clock_source_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_clock_source_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_clock_source_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_clock_source_response_write(
    struct jdksavdecc_aem_command_set_clock_source_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CLOCK_SOURCE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_clock_source_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_clock_source_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_clock_source_response_set_clock_source_index(p->clock_source_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_clock_source GET_CLOCK_SOURCE Command - Clause 7.4.24.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_clock_source_get_controller_entity_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_clock_source_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_CLOCK_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_clock_source GET_CLOCK_SOURCE Command - Clause 7.4.24.1 */
/*@{*/

/// GET_CLOCK_SOURCE Command - Clause 7.4.24.1
struct jdksavdecc_aem_command_get_clock_source {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_clock_source structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_clock_source structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_clock_source_read(struct jdksavdecc_aem_command_get_clock_source *p,
                                                                   void const *base,
                                                                   ssize_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_clock_source_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_clock_source_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_clock_source structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_clock_source structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_clock_source_write(struct jdksavdecc_aem_command_get_clock_source const *p,
                                                                    void *base,
                                                                    size_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_clock_source_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_clock_source_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_clock_source_response GET_CLOCK_SOURCE Response -
 * Clause 7.4.24.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_clock_source_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_clock_source_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_clock_source_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the clock_source_index field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_clock_source_response_get_clock_source_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_CLOCK_SOURCE_INDEX);
}

/**
 * Store a uint16 value to the clock_source_index field of the
 *COMMAND_GET_CLOCK_SOURCE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_clock_source_response_set_clock_source_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_OFFSET_CLOCK_SOURCE_INDEX);
}

/*@}*/

/** \addtogroup command_get_clock_source_response GET_CLOCK_SOURCE Response -
 * Clause 7.4.24.2 */
/*@{*/

/// GET_CLOCK_SOURCE Response - Clause 7.4.24.2
struct jdksavdecc_aem_command_get_clock_source_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t clock_source_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_clock_source_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_clock_source_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_clock_source_response_read(
    struct jdksavdecc_aem_command_get_clock_source_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_clock_source_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_clock_source_response_get_descriptor_index(base, pos);
        p->clock_source_index = jdksavdecc_aem_command_get_clock_source_response_get_clock_source_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_clock_source_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_clock_source_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_clock_source_response_write(
    struct jdksavdecc_aem_command_get_clock_source_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CLOCK_SOURCE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_clock_source_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_clock_source_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_clock_source_response_set_clock_source_index(p->clock_source_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_control SET_CONTROL Command - Clause 7.4.25.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_control_get_controller_entity_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_control_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_SET_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_SET_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_SET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_SET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_SET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_set_control SET_CONTROL Command - Clause 7.4.25.1 */
/*@{*/

/// SET_CONTROL Command - Clause 7.4.25.1
struct jdksavdecc_aem_command_set_control {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_control structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_control structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_control_read(struct jdksavdecc_aem_command_set_control *p,
                                                              void const *base,
                                                              ssize_t pos,
                                                              size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_control_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_control_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_control structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_control structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_control_write(struct jdksavdecc_aem_command_set_control const *p,
                                                               void *base,
                                                               size_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_control_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_control_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_control_response SET_CONTROL Response - Clause 7.4.25.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_control_response_get_controller_entity_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_control_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_control_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_control_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_set_control_response SET_CONTROL Response - Clause 7.4.25.1 */
/*@{*/

/// SET_CONTROL Response - Clause 7.4.25.1
struct jdksavdecc_aem_command_set_control_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_control_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_control_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_control_response_read(struct jdksavdecc_aem_command_set_control_response *p,
                                                                       void const *base,
                                                                       ssize_t pos,
                                                                       size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_control_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_control_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_control_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_control_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_control_response_write(
    struct jdksavdecc_aem_command_set_control_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_control_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_control_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_control GET_CONTROL Command - Clause 7.4.26.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_control_get_controller_entity_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_control_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_GET_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_GET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_GET_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_control GET_CONTROL Command - Clause 7.4.26.1 */
/*@{*/

/// GET_CONTROL Command - Clause 7.4.26.1
struct jdksavdecc_aem_command_get_control {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_control structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_control structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_control_read(struct jdksavdecc_aem_command_get_control *p,
                                                              void const *base,
                                                              ssize_t pos,
                                                              size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_control_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_control_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_control structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_control structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_control_write(struct jdksavdecc_aem_command_get_control const *p,
                                                               void *base,
                                                               size_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_control_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_control_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_control_response GET_CONTROL Response - Clause 7.4.26.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_control_response_get_controller_entity_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_control_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_control_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_control_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_control_response GET_CONTROL Response - Clause 7.4.26.2 */
/*@{*/

/// GET_CONTROL Response - Clause 7.4.26.2
struct jdksavdecc_aem_command_get_control_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_control_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_control_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_control_response_read(struct jdksavdecc_aem_command_get_control_response *p,
                                                                       void const *base,
                                                                       ssize_t pos,
                                                                       size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_control_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_control_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_control_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_control_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_control_response_write(
    struct jdksavdecc_aem_command_get_control_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_control_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_control_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_increment_control INCREMENT_CONTROL Command - Clause 7.4.27.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_increment_control_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_INCREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_increment_control_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_INCREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_INCREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_INCREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_INCREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the index_count field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t index_count value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_get_index_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_INDEX_COUNT);
}

/**
 * Store a uint16 value to the index_count field of the
 *COMMAND_INCREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t index_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_set_index_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_INDEX_COUNT);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_INCREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_INCREMENT_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_increment_control INCREMENT_CONTROL Command - Clause 7.4.27.1 */
/*@{*/

/// INCREMENT_CONTROL Command - Clause 7.4.27.1
struct jdksavdecc_aem_command_increment_control {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t index_count;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_increment_control structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_increment_control structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_increment_control_read(struct jdksavdecc_aem_command_increment_control *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_increment_control_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_increment_control_get_descriptor_index(base, pos);
        p->index_count = jdksavdecc_aem_command_increment_control_get_index_count(base, pos);
        p->reserved = jdksavdecc_aem_command_increment_control_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_increment_control structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_increment_control structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_increment_control_write(struct jdksavdecc_aem_command_increment_control const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_increment_control_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_increment_control_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_increment_control_set_index_count(p->index_count, base, pos);
        jdksavdecc_aem_command_increment_control_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_increment_control_response INCREMENT_CONTROL Response -
 * Clause 7.4.27.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_increment_control_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_increment_control_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_increment_control_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_INCREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_increment_control_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_increment_control_response INCREMENT_CONTROL Response -
 * Clause 7.4.27.2 */
/*@{*/

/// INCREMENT_CONTROL Response - Clause 7.4.27.2
struct jdksavdecc_aem_command_increment_control_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_increment_control_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_increment_control_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_increment_control_response_read(
    struct jdksavdecc_aem_command_increment_control_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_increment_control_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_increment_control_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_increment_control_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_increment_control_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_increment_control_response_write(
    struct jdksavdecc_aem_command_increment_control_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_INCREMENT_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_increment_control_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_increment_control_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_decrement_control DECREMENT_CONTROL Command - Clause 7.4.28.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_decrement_control_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DECREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_decrement_control_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DECREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DECREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_DECREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_DECREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the index_count field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t index_count value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_get_index_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_INDEX_COUNT);
}

/**
 * Store a uint16 value to the index_count field of the
 *COMMAND_DECREMENT_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t index_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_set_index_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_INDEX_COUNT);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_DECREMENT_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_DECREMENT_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_decrement_control DECREMENT_CONTROL Command - Clause 7.4.28.1 */
/*@{*/

/// DECREMENT_CONTROL Command - Clause 7.4.28.1
struct jdksavdecc_aem_command_decrement_control {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t index_count;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_decrement_control structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_decrement_control structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_decrement_control_read(struct jdksavdecc_aem_command_decrement_control *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_decrement_control_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_decrement_control_get_descriptor_index(base, pos);
        p->index_count = jdksavdecc_aem_command_decrement_control_get_index_count(base, pos);
        p->reserved = jdksavdecc_aem_command_decrement_control_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_decrement_control structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_decrement_control structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_decrement_control_write(struct jdksavdecc_aem_command_decrement_control const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_decrement_control_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_decrement_control_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_decrement_control_set_index_count(p->index_count, base, pos);
        jdksavdecc_aem_command_decrement_control_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_decrement_control_response DECREMENT_CONTROL Response -
 * Clause 7.4.28.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_decrement_control_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_decrement_control_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_decrement_control_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_DECREMENT_CONTROL_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_decrement_control_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_decrement_control_response DECREMENT_CONTROL Response -
 * Clause 7.4.28.2 */
/*@{*/

/// DECREMENT_CONTROL Response - Clause 7.4.28.2
struct jdksavdecc_aem_command_decrement_control_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_decrement_control_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_decrement_control_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_decrement_control_response_read(
    struct jdksavdecc_aem_command_decrement_control_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_decrement_control_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_decrement_control_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_decrement_control_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_decrement_control_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_decrement_control_response_write(
    struct jdksavdecc_aem_command_decrement_control_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DECREMENT_CONTROL_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_decrement_control_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_decrement_control_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_signal_selector SET_SIGNAL_SELECTOR Command - Clause 7.4.29.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_signal_selector_get_controller_entity_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_signal_selector_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *COMMAND_SET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_SET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_SET_SIGNAL_SELECTOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_set_signal_selector SET_SIGNAL_SELECTOR Command - Clause 7.4.29.1 */
/*@{*/

/// SET_SIGNAL_SELECTOR Command - Clause 7.4.29.1
struct jdksavdecc_aem_command_set_signal_selector {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_set_signal_selector structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_signal_selector structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_signal_selector_read(struct jdksavdecc_aem_command_set_signal_selector *p,
                                                                      void const *base,
                                                                      ssize_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_signal_selector_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_signal_selector_get_descriptor_index(base, pos);
        p->signal_type = jdksavdecc_aem_command_set_signal_selector_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_aem_command_set_signal_selector_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_aem_command_set_signal_selector_get_signal_output(base, pos);
        p->reserved = jdksavdecc_aem_command_set_signal_selector_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_signal_selector structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_signal_selector structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_signal_selector_write(
    struct jdksavdecc_aem_command_set_signal_selector const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_signal_selector_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_signal_selector_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_signal_selector_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_aem_command_set_signal_selector_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_aem_command_set_signal_selector_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_aem_command_set_signal_selector_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_signal_selector_response SET_SIGNAL_SELECTOR
 * Response - Clause 7.4.29.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_signal_selector_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                void *base,
                                                                                                ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_signal_selector_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_signal_selector_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_set_signal_selector_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_SET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_signal_selector_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_set_signal_selector_response SET_SIGNAL_SELECTOR
 * Response - Clause 7.4.29.1 */
/*@{*/

/// SET_SIGNAL_SELECTOR Response - Clause 7.4.29.1
struct jdksavdecc_aem_command_set_signal_selector_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_set_signal_selector_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_signal_selector_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_signal_selector_response_read(
    struct jdksavdecc_aem_command_set_signal_selector_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_signal_selector_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_signal_selector_response_get_descriptor_index(base, pos);
        p->signal_type = jdksavdecc_aem_command_set_signal_selector_response_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_aem_command_set_signal_selector_response_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_aem_command_set_signal_selector_response_get_signal_output(base, pos);
        p->reserved = jdksavdecc_aem_command_set_signal_selector_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_signal_selector_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_signal_selector_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_signal_selector_response_write(
    struct jdksavdecc_aem_command_set_signal_selector_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_SIGNAL_SELECTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_signal_selector_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_signal_selector_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_signal_selector_response_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_aem_command_set_signal_selector_response_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_aem_command_set_signal_selector_response_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_aem_command_set_signal_selector_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_signal_selector GET_SIGNAL_SELECTOR Command - Clause 7.4.30.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_signal_selector_get_controller_entity_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_signal_selector_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_signal_selector GET_SIGNAL_SELECTOR Command - Clause 7.4.30.1 */
/*@{*/

/// GET_SIGNAL_SELECTOR Command - Clause 7.4.30.1
struct jdksavdecc_aem_command_get_signal_selector {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_signal_selector structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_signal_selector structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_signal_selector_read(struct jdksavdecc_aem_command_get_signal_selector *p,
                                                                      void const *base,
                                                                      ssize_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_signal_selector_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_signal_selector_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_signal_selector structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_signal_selector structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_signal_selector_write(
    struct jdksavdecc_aem_command_get_signal_selector const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_signal_selector_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_signal_selector_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_signal_selector_response GET_SIGNAL_SELECTOR
 * Response - Clause 7.4.30.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_signal_selector_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                void *base,
                                                                                                ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_signal_selector_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_signal_selector_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_signal_selector_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_GET_SIGNAL_SELECTOR_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_signal_selector_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_signal_selector_response GET_SIGNAL_SELECTOR
 * Response - Clause 7.4.30.2 */
/*@{*/

/// GET_SIGNAL_SELECTOR Response - Clause 7.4.30.2
struct jdksavdecc_aem_command_get_signal_selector_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_signal_selector_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_signal_selector_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_signal_selector_response_read(
    struct jdksavdecc_aem_command_get_signal_selector_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_signal_selector_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_signal_selector_response_get_descriptor_index(base, pos);
        p->signal_type = jdksavdecc_aem_command_get_signal_selector_response_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_aem_command_get_signal_selector_response_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_aem_command_get_signal_selector_response_get_signal_output(base, pos);
        p->reserved = jdksavdecc_aem_command_get_signal_selector_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_signal_selector_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_signal_selector_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_signal_selector_response_write(
    struct jdksavdecc_aem_command_get_signal_selector_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SIGNAL_SELECTOR_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_signal_selector_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_signal_selector_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_signal_selector_response_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_aem_command_get_signal_selector_response_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_aem_command_get_signal_selector_response_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_aem_command_get_signal_selector_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_mixer SET_MIXER Command - Clause 7.4.31.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_mixer_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_MIXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_mixer_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_SET_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_MIXER object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_SET_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_SET_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_SET_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_SET_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_set_mixer SET_MIXER Command - Clause 7.4.31.1 */
/*@{*/

/// SET_MIXER Command - Clause 7.4.31.1
struct jdksavdecc_aem_command_set_mixer {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_mixer structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_mixer structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_set_mixer_read(struct jdksavdecc_aem_command_set_mixer *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_mixer_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_mixer_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_mixer structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_mixer structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_set_mixer_write(struct jdksavdecc_aem_command_set_mixer const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MIXER_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_mixer_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_mixer_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_mixer_response SET_MIXER Response - Clause 7.4.31.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_mixer_response_get_controller_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_mixer_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_mixer_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_mixer_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_set_mixer_response SET_MIXER Response - Clause 7.4.31.1
 */
/*@{*/

/// SET_MIXER Response - Clause 7.4.31.1
struct jdksavdecc_aem_command_set_mixer_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_set_mixer_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_mixer_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_mixer_response_read(struct jdksavdecc_aem_command_set_mixer_response *p,
                                                                     void const *base,
                                                                     ssize_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_mixer_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_mixer_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_mixer_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_mixer_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_mixer_response_write(struct jdksavdecc_aem_command_set_mixer_response const *p,
                                                                      void *base,
                                                                      size_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MIXER_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_mixer_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_mixer_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_mixer GET_MIXER Command - Clause 7.4.32.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_mixer_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_MIXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_mixer_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_MIXER object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_GET_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_GET_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_GET_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_mixer GET_MIXER Command - Clause 7.4.32.1 */
/*@{*/

/// GET_MIXER Command - Clause 7.4.32.1
struct jdksavdecc_aem_command_get_mixer {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_mixer structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_mixer structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_get_mixer_read(struct jdksavdecc_aem_command_get_mixer *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_mixer_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_mixer_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_mixer structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_mixer structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_get_mixer_write(struct jdksavdecc_aem_command_get_mixer const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MIXER_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_mixer_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_mixer_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_mixer_response GET_MIXER Response - Clause 7.4.32.2
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_mixer_response_get_controller_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_mixer_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_MIXER_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_mixer_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_MIXER_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_mixer_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_mixer_response GET_MIXER Response - Clause 7.4.32.2
 */
/*@{*/

/// GET_MIXER Response - Clause 7.4.32.2
struct jdksavdecc_aem_command_get_mixer_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_mixer_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_mixer_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_mixer_response_read(struct jdksavdecc_aem_command_get_mixer_response *p,
                                                                     void const *base,
                                                                     ssize_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_mixer_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_mixer_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_mixer_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_mixer_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_mixer_response_write(struct jdksavdecc_aem_command_get_mixer_response const *p,
                                                                      void *base,
                                                                      size_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MIXER_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_mixer_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_mixer_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_matrix SET_MATRIX Command - Clause 7.4.33.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_matrix_get_controller_entity_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_MATRIX object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_matrix_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the matrix_column field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_column value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_matrix_column(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_MATRIX_COLUMN);
}

/**
 * Store a uint16 value to the matrix_column field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_column value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_matrix_column(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_MATRIX_COLUMN);
}

/**
 * Extract the uint16 value of the matrix_row field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_row value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_matrix_row(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_MATRIX_ROW);
}

/**
 * Store a uint16 value to the matrix_row field of the COMMAND_SET_MATRIX object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_row value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_matrix_row(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_MATRIX_ROW);
}

/**
 * Extract the uint16 value of the region_width field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_width value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_region_width(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REGION_WIDTH);
}

/**
 * Store a uint16 value to the region_width field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_width value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_region_width(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REGION_WIDTH);
}

/**
 * Extract the uint16 value of the region_height field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_height value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_region_height(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REGION_HEIGHT);
}

/**
 * Store a uint16 value to the region_height field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_height value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_region_height(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REGION_HEIGHT);
}

/**
 * Extract the uint16 value of the rep_direction_value_count field of the
 *COMMAND_SET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t rep_direction_value_count value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_rep_direction_value_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REP_DIRECTION_VALUE_COUNT);
}

/**
 * Store a uint16 value to the rep_direction_value_count field of the
 *COMMAND_SET_MATRIX object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t rep_direction_value_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_rep_direction_value_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_REP_DIRECTION_VALUE_COUNT);
}

/**
 * Extract the uint16 value of the item_offset field of the COMMAND_SET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t item_offset value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_get_item_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_ITEM_OFFSET);
}

/**
 * Store a uint16 value to the item_offset field of the COMMAND_SET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t item_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_set_item_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_OFFSET_ITEM_OFFSET);
}

/*@}*/

/** \addtogroup command_set_matrix SET_MATRIX Command - Clause 7.4.33.1 */
/*@{*/

/// SET_MATRIX Command - Clause 7.4.33.1
struct jdksavdecc_aem_command_set_matrix {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t matrix_column;
    uint16_t matrix_row;
    uint16_t region_width;
    uint16_t region_height;
    uint16_t rep_direction_value_count;
    uint16_t item_offset;
};

/**
 * Extract the jdksavdecc_aem_command_set_matrix structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_matrix structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_set_matrix_read(struct jdksavdecc_aem_command_set_matrix *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_matrix_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_matrix_get_descriptor_index(base, pos);
        p->matrix_column = jdksavdecc_aem_command_set_matrix_get_matrix_column(base, pos);
        p->matrix_row = jdksavdecc_aem_command_set_matrix_get_matrix_row(base, pos);
        p->region_width = jdksavdecc_aem_command_set_matrix_get_region_width(base, pos);
        p->region_height = jdksavdecc_aem_command_set_matrix_get_region_height(base, pos);
        p->rep_direction_value_count = jdksavdecc_aem_command_set_matrix_get_rep_direction_value_count(base, pos);
        p->item_offset = jdksavdecc_aem_command_set_matrix_get_item_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_matrix structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_matrix structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_set_matrix_write(struct jdksavdecc_aem_command_set_matrix const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MATRIX_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_matrix_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_matrix_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_matrix_set_matrix_column(p->matrix_column, base, pos);
        jdksavdecc_aem_command_set_matrix_set_matrix_row(p->matrix_row, base, pos);
        jdksavdecc_aem_command_set_matrix_set_region_width(p->region_width, base, pos);
        jdksavdecc_aem_command_set_matrix_set_region_height(p->region_height, base, pos);
        jdksavdecc_aem_command_set_matrix_set_rep_direction_value_count(p->rep_direction_value_count, base, pos);
        jdksavdecc_aem_command_set_matrix_set_item_offset(p->item_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_matrix_response SET_MATRIX Response - Clause 7.4.33.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_matrix_response_get_controller_entity_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_matrix_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the matrix_column field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_column value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_matrix_column(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_MATRIX_COLUMN);
}

/**
 * Store a uint16 value to the matrix_column field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_column value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_matrix_column(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_MATRIX_COLUMN);
}

/**
 * Extract the uint16 value of the matrix_row field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_row value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_matrix_row(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_MATRIX_ROW);
}

/**
 * Store a uint16 value to the matrix_row field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_row value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_matrix_row(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_MATRIX_ROW);
}

/**
 * Extract the uint16 value of the region_width field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_width value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_region_width(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REGION_WIDTH);
}

/**
 * Store a uint16 value to the region_width field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_width value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_region_width(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REGION_WIDTH);
}

/**
 * Extract the uint16 value of the region_height field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_height value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_region_height(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REGION_HEIGHT);
}

/**
 * Store a uint16 value to the region_height field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_height value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_region_height(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REGION_HEIGHT);
}

/**
 * Extract the uint16 value of the rep_direction_value_count field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t rep_direction_value_count value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_rep_direction_value_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REP_DIRECTION_VALUE_COUNT);
}

/**
 * Store a uint16 value to the rep_direction_value_count field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t rep_direction_value_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_matrix_response_set_rep_direction_value_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_REP_DIRECTION_VALUE_COUNT);
}

/**
 * Extract the uint16 value of the item_offset field of the
 *COMMAND_SET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t item_offset value
 */
static inline uint16_t jdksavdecc_aem_command_set_matrix_response_get_item_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_ITEM_OFFSET);
}

/**
 * Store a uint16 value to the item_offset field of the
 *COMMAND_SET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t item_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_matrix_response_set_item_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_OFFSET_ITEM_OFFSET);
}

/*@}*/

/** \addtogroup command_set_matrix_response SET_MATRIX Response - Clause 7.4.33.2 */
/*@{*/

/// SET_MATRIX Response - Clause 7.4.33.2
struct jdksavdecc_aem_command_set_matrix_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t matrix_column;
    uint16_t matrix_row;
    uint16_t region_width;
    uint16_t region_height;
    uint16_t rep_direction_value_count;
    uint16_t item_offset;
};

/**
 * Extract the jdksavdecc_aem_command_set_matrix_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_matrix_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_matrix_response_read(struct jdksavdecc_aem_command_set_matrix_response *p,
                                                                      void const *base,
                                                                      ssize_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_matrix_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_matrix_response_get_descriptor_index(base, pos);
        p->matrix_column = jdksavdecc_aem_command_set_matrix_response_get_matrix_column(base, pos);
        p->matrix_row = jdksavdecc_aem_command_set_matrix_response_get_matrix_row(base, pos);
        p->region_width = jdksavdecc_aem_command_set_matrix_response_get_region_width(base, pos);
        p->region_height = jdksavdecc_aem_command_set_matrix_response_get_region_height(base, pos);
        p->rep_direction_value_count = jdksavdecc_aem_command_set_matrix_response_get_rep_direction_value_count(base, pos);
        p->item_offset = jdksavdecc_aem_command_set_matrix_response_get_item_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_matrix_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_matrix_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_matrix_response_write(
    struct jdksavdecc_aem_command_set_matrix_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MATRIX_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_matrix_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_matrix_column(p->matrix_column, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_matrix_row(p->matrix_row, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_region_width(p->region_width, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_region_height(p->region_height, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_rep_direction_value_count(p->rep_direction_value_count, base, pos);
        jdksavdecc_aem_command_set_matrix_response_set_item_offset(p->item_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_matrix GET_MATRIX Command - Clause 7.4.34.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_matrix_get_controller_entity_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_MATRIX object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_matrix_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the matrix_column field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_column value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_matrix_column(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_MATRIX_COLUMN);
}

/**
 * Store a uint16 value to the matrix_column field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_column value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_matrix_column(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_MATRIX_COLUMN);
}

/**
 * Extract the uint16 value of the matrix_row field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_row value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_matrix_row(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_MATRIX_ROW);
}

/**
 * Store a uint16 value to the matrix_row field of the COMMAND_GET_MATRIX object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_row value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_matrix_row(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_MATRIX_ROW);
}

/**
 * Extract the uint16 value of the region_width field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_width value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_region_width(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_REGION_WIDTH);
}

/**
 * Store a uint16 value to the region_width field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_width value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_region_width(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_REGION_WIDTH);
}

/**
 * Extract the uint16 value of the region_height field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_height value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_region_height(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_REGION_HEIGHT);
}

/**
 * Store a uint16 value to the region_height field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_height value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_region_height(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_REGION_HEIGHT);
}

/**
 * Extract the uint16 value of the res_direction_value_count field of the
 *COMMAND_GET_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t res_direction_value_count value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_res_direction_value_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_RES_DIRECTION_VALUE_COUNT);
}

/**
 * Store a uint16 value to the res_direction_value_count field of the
 *COMMAND_GET_MATRIX object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t res_direction_value_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_res_direction_value_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_RES_DIRECTION_VALUE_COUNT);
}

/**
 * Extract the uint16 value of the item_offset field of the COMMAND_GET_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t item_offset value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_get_item_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_ITEM_OFFSET);
}

/**
 * Store a uint16 value to the item_offset field of the COMMAND_GET_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t item_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_set_item_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_OFFSET_ITEM_OFFSET);
}

/*@}*/

/** \addtogroup command_get_matrix GET_MATRIX Command - Clause 7.4.34.1 */
/*@{*/

/// GET_MATRIX Command - Clause 7.4.34.1
struct jdksavdecc_aem_command_get_matrix {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t matrix_column;
    uint16_t matrix_row;
    uint16_t region_width;
    uint16_t region_height;
    uint16_t res_direction_value_count;
    uint16_t item_offset;
};

/**
 * Extract the jdksavdecc_aem_command_get_matrix structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_matrix structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_get_matrix_read(struct jdksavdecc_aem_command_get_matrix *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_matrix_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_matrix_get_descriptor_index(base, pos);
        p->matrix_column = jdksavdecc_aem_command_get_matrix_get_matrix_column(base, pos);
        p->matrix_row = jdksavdecc_aem_command_get_matrix_get_matrix_row(base, pos);
        p->region_width = jdksavdecc_aem_command_get_matrix_get_region_width(base, pos);
        p->region_height = jdksavdecc_aem_command_get_matrix_get_region_height(base, pos);
        p->res_direction_value_count = jdksavdecc_aem_command_get_matrix_get_res_direction_value_count(base, pos);
        p->item_offset = jdksavdecc_aem_command_get_matrix_get_item_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_matrix structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_matrix structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_get_matrix_write(struct jdksavdecc_aem_command_get_matrix const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MATRIX_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_matrix_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_matrix_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_matrix_set_matrix_column(p->matrix_column, base, pos);
        jdksavdecc_aem_command_get_matrix_set_matrix_row(p->matrix_row, base, pos);
        jdksavdecc_aem_command_get_matrix_set_region_width(p->region_width, base, pos);
        jdksavdecc_aem_command_get_matrix_set_region_height(p->region_height, base, pos);
        jdksavdecc_aem_command_get_matrix_set_res_direction_value_count(p->res_direction_value_count, base, pos);
        jdksavdecc_aem_command_get_matrix_set_item_offset(p->item_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_matrix_response GET_MATRIX Response - Clause 7.4.34.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_matrix_response_get_controller_entity_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_matrix_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the matrix_column field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_column value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_matrix_column(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_MATRIX_COLUMN);
}

/**
 * Store a uint16 value to the matrix_column field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_column value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_matrix_column(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_MATRIX_COLUMN);
}

/**
 * Extract the uint16 value of the matrix_row field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t matrix_row value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_matrix_row(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_MATRIX_ROW);
}

/**
 * Store a uint16 value to the matrix_row field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t matrix_row value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_matrix_row(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_MATRIX_ROW);
}

/**
 * Extract the uint16 value of the region_width field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_width value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_region_width(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_REGION_WIDTH);
}

/**
 * Store a uint16 value to the region_width field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_width value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_region_width(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_REGION_WIDTH);
}

/**
 * Extract the uint16 value of the region_height field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t region_height value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_region_height(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_REGION_HEIGHT);
}

/**
 * Store a uint16 value to the region_height field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t region_height value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_region_height(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_REGION_HEIGHT);
}

/**
 * Extract the uint16 value of the res_direction_value_count field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t res_direction_value_count value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_res_direction_value_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_RES_DIRECTION_VALUE_COUNT);
}

/**
 * Store a uint16 value to the res_direction_value_count field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t res_direction_value_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_matrix_response_set_res_direction_value_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_RES_DIRECTION_VALUE_COUNT);
}

/**
 * Extract the uint16 value of the item_offset field of the
 *COMMAND_GET_MATRIX_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t item_offset value
 */
static inline uint16_t jdksavdecc_aem_command_get_matrix_response_get_item_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_ITEM_OFFSET);
}

/**
 * Store a uint16 value to the item_offset field of the
 *COMMAND_GET_MATRIX_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t item_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_matrix_response_set_item_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_OFFSET_ITEM_OFFSET);
}

/*@}*/

/** \addtogroup command_get_matrix_response GET_MATRIX Response - Clause 7.4.34.2 */
/*@{*/

/// GET_MATRIX Response - Clause 7.4.34.2
struct jdksavdecc_aem_command_get_matrix_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t matrix_column;
    uint16_t matrix_row;
    uint16_t region_width;
    uint16_t region_height;
    uint16_t res_direction_value_count;
    uint16_t item_offset;
};

/**
 * Extract the jdksavdecc_aem_command_get_matrix_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_matrix_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_matrix_response_read(struct jdksavdecc_aem_command_get_matrix_response *p,
                                                                      void const *base,
                                                                      ssize_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_matrix_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_matrix_response_get_descriptor_index(base, pos);
        p->matrix_column = jdksavdecc_aem_command_get_matrix_response_get_matrix_column(base, pos);
        p->matrix_row = jdksavdecc_aem_command_get_matrix_response_get_matrix_row(base, pos);
        p->region_width = jdksavdecc_aem_command_get_matrix_response_get_region_width(base, pos);
        p->region_height = jdksavdecc_aem_command_get_matrix_response_get_region_height(base, pos);
        p->res_direction_value_count = jdksavdecc_aem_command_get_matrix_response_get_res_direction_value_count(base, pos);
        p->item_offset = jdksavdecc_aem_command_get_matrix_response_get_item_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_matrix_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_matrix_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_matrix_response_write(
    struct jdksavdecc_aem_command_get_matrix_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MATRIX_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_matrix_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_matrix_column(p->matrix_column, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_matrix_row(p->matrix_row, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_region_width(p->region_width, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_region_height(p->region_height, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_res_direction_value_count(p->res_direction_value_count, base, pos);
        jdksavdecc_aem_command_get_matrix_response_set_item_offset(p->item_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_start_streaming START_STREAMING Command - Clause 7.4.35.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_START_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_start_streaming_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_START_STREAMING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_start_streaming_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_START_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_START_STREAMING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_START_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_START_STREAMING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_START_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_START_STREAMING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_START_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_START_STREAMING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_start_streaming START_STREAMING Command - Clause 7.4.35.1 */
/*@{*/

/// START_STREAMING Command - Clause 7.4.35.1
struct jdksavdecc_aem_command_start_streaming {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_start_streaming structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_start_streaming structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_streaming_read(struct jdksavdecc_aem_command_start_streaming *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_start_streaming_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_start_streaming_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_start_streaming structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_start_streaming structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_streaming_write(struct jdksavdecc_aem_command_start_streaming const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_STREAMING_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_start_streaming_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_start_streaming_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_start_streaming_response START_STREAMING Response -
 * Clause 7.4.35.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_START_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_start_streaming_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_START_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_start_streaming_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_START_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_START_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_START_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_START_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_START_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_START_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_START_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_start_streaming_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_START_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_streaming_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_start_streaming_response START_STREAMING Response -
 * Clause 7.4.35.1 */
/*@{*/

/// START_STREAMING Response - Clause 7.4.35.1
struct jdksavdecc_aem_command_start_streaming_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_start_streaming_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_start_streaming_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_streaming_response_read(
    struct jdksavdecc_aem_command_start_streaming_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_start_streaming_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_start_streaming_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_start_streaming_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_start_streaming_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_streaming_response_write(
    struct jdksavdecc_aem_command_start_streaming_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_STREAMING_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_start_streaming_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_start_streaming_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_stop_streaming STOP_STREAMING Command - Clause 7.4.36.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_STOP_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_stop_streaming_get_controller_entity_id(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_STOP_STREAMING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_stop_streaming_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_STOP_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_STOP_STREAMING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_STOP_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_STOP_STREAMING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_STOP_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_STOP_STREAMING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_STOP_STREAMING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_STOP_STREAMING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_stop_streaming STOP_STREAMING Command - Clause 7.4.36.1
 */
/*@{*/

/// STOP_STREAMING Command - Clause 7.4.36.1
struct jdksavdecc_aem_command_stop_streaming {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_stop_streaming structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_stop_streaming structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_stop_streaming_read(struct jdksavdecc_aem_command_stop_streaming *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_stop_streaming_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_stop_streaming_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_stop_streaming structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_stop_streaming structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_stop_streaming_write(struct jdksavdecc_aem_command_stop_streaming const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_stop_streaming_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_stop_streaming_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_stop_streaming_response STOP_STREAMING Response - Clause 7.4.36.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_STOP_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_stop_streaming_response_get_controller_entity_id(void const *base,
                                                                                                              ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_STOP_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_stop_streaming_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_STOP_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_STOP_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_STOP_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_STOP_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_STOP_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_STOP_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_STOP_STREAMING_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_stop_streaming_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_STOP_STREAMING_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_stop_streaming_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_stop_streaming_response STOP_STREAMING Response - Clause 7.4.36.1 */
/*@{*/

/// STOP_STREAMING Response - Clause 7.4.36.1
struct jdksavdecc_aem_command_stop_streaming_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_stop_streaming_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_stop_streaming_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_stop_streaming_response_read(
    struct jdksavdecc_aem_command_stop_streaming_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_stop_streaming_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_stop_streaming_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_stop_streaming_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_stop_streaming_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_stop_streaming_response_write(
    struct jdksavdecc_aem_command_stop_streaming_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_STOP_STREAMING_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_stop_streaming_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_stop_streaming_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_register_unsolicited_notification
 * REGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.37.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_register_unsolicited_notification_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(
        base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_register_unsolicited_notification_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                     void *base,
                                                                                                     ssize_t pos) {
    jdksavdecc_eui64_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_register_unsolicited_notification_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_register_unsolicited_notification_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_register_unsolicited_notification_get_command_type(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_register_unsolicited_notification_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_register_unsolicited_notification
 * REGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.37.1 */
/*@{*/

/// REGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.37.1
struct jdksavdecc_aem_command_register_unsolicited_notification {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_register_unsolicited_notification
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_register_unsolicited_notification structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_register_unsolicited_notification_read(
    struct jdksavdecc_aem_command_register_unsolicited_notification *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_register_unsolicited_notification structure
 *to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_register_unsolicited_notification structure
 *to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_register_unsolicited_notification_write(
    struct jdksavdecc_aem_command_register_unsolicited_notification const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_register_unsolicited_notification_response
 * REGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.37.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_register_unsolicited_notification_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(
        base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_register_unsolicited_notification_response_set_controller_entity_id(
    struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_register_unsolicited_notification_response_get_sequence_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_register_unsolicited_notification_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_register_unsolicited_notification_response_get_command_type(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_register_unsolicited_notification_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_register_unsolicited_notification_response
 * REGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.37.1 */
/*@{*/

/// REGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.37.1
struct jdksavdecc_aem_command_register_unsolicited_notification_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_register_unsolicited_notification_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_register_unsolicited_notification_response
 *structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_register_unsolicited_notification_response_read(
    struct jdksavdecc_aem_command_register_unsolicited_notification_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_register_unsolicited_notification_response
 *structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_register_unsolicited_notification_response
 *structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_register_unsolicited_notification_response_write(
    struct jdksavdecc_aem_command_register_unsolicited_notification_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_deregister_unsolicited_notification
 * DEREGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.38.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_deregister_unsolicited_notification_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(
        base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deregister_unsolicited_notification_set_controller_entity_id(
    struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_deregister_unsolicited_notification_get_sequence_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_deregister_unsolicited_notification_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_deregister_unsolicited_notification_get_command_type(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_deregister_unsolicited_notification_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_deregister_unsolicited_notification
 * DEREGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.38.1 */
/*@{*/

/// DEREGISTER_UNSOLICITED_NOTIFICATION Command - Clause 7.4.38.1
struct jdksavdecc_aem_command_deregister_unsolicited_notification {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_deregister_unsolicited_notification
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_deregister_unsolicited_notification structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deregister_unsolicited_notification_read(
    struct jdksavdecc_aem_command_deregister_unsolicited_notification *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_deregister_unsolicited_notification
 *structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_deregister_unsolicited_notification
 *structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deregister_unsolicited_notification_write(
    struct jdksavdecc_aem_command_deregister_unsolicited_notification const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_deregister_unsolicited_notification_response
 * DEREGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.38.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object from
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_deregister_unsolicited_notification_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(
        base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deregister_unsolicited_notification_response_set_controller_entity_id(
    struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_deregister_unsolicited_notification_response_get_sequence_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_deregister_unsolicited_notification_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_deregister_unsolicited_notification_response_get_command_type(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_deregister_unsolicited_notification_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(
        v, base, pos + JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_deregister_unsolicited_notification_response
 * DEREGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.38.1
 */
/*@{*/

/// DEREGISTER_UNSOLICITED_NOTIFICATION Response - Clause 7.4.38.1
struct jdksavdecc_aem_command_deregister_unsolicited_notification_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the
 *jdksavdecc_aem_command_deregister_unsolicited_notification_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_deregister_unsolicited_notification_response
 *structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deregister_unsolicited_notification_response_read(
    struct jdksavdecc_aem_command_deregister_unsolicited_notification_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_deregister_unsolicited_notification_response
 *structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to
 *command_deregister_unsolicited_notification_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deregister_unsolicited_notification_response_write(
    struct jdksavdecc_aem_command_deregister_unsolicited_notification_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEREGISTER_UNSOLICITED_NOTIFICATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_identify_notification IDENTIFY_NOTIFICATION Unsolicited
 * Response - Clause 7.4.39.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_IDENTIFY_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_identify_notification_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_IDENTIFY_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_identify_notification_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_IDENTIFY_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_identify_notification_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_IDENTIFY_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_identify_notification_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_IDENTIFY_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_identify_notification_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_IDENTIFY_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_identify_notification_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_IDENTIFY_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_identify_notification_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_IDENTIFY_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_identify_notification_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_IDENTIFY_NOTIFICATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_identify_notification_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_IDENTIFY_NOTIFICATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_identify_notification_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_identify_notification IDENTIFY_NOTIFICATION Unsolicited
 * Response - Clause 7.4.39.1 */
/*@{*/

/// IDENTIFY_NOTIFICATION Unsolicited Response - Clause 7.4.39.1
struct jdksavdecc_aem_command_identify_notification {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_identify_notification structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_identify_notification structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_identify_notification_read(struct jdksavdecc_aem_command_identify_notification *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_identify_notification_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_identify_notification_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_identify_notification structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_identify_notification structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_identify_notification_write(
    struct jdksavdecc_aem_command_identify_notification const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_IDENTIFY_NOTIFICATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_identify_notification_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_identify_notification_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_avb_info GET_AVB_INFO Command  - Clause 7.4.40.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_AVB_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_avb_info_get_controller_entity_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_AVB_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_avb_info_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_AVB_INFO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_AVB_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_AVB_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_AVB_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_AVB_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_GET_AVB_INFO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_AVB_INFO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_AVB_INFO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_avb_info GET_AVB_INFO Command  - Clause 7.4.40.1 */
/*@{*/

/// GET_AVB_INFO Command  - Clause 7.4.40.1
struct jdksavdecc_aem_command_get_avb_info {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_avb_info structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_avb_info structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_avb_info_read(struct jdksavdecc_aem_command_get_avb_info *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_avb_info_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_avb_info_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_avb_info structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_avb_info structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_avb_info_write(struct jdksavdecc_aem_command_get_avb_info const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_avb_info_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_avb_info_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_avb_info_response GET_AVB_INFO Response  - Clause 7.4.40.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_avb_info_response_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_avb_info_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the gptp_grandmaster_id field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 as_grandmaster_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_avb_info_response_get_gptp_grandmaster_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_GPTP_GRANDMASTER_ID);
}

/**
 * Store a eui64 value to the gptp_grandmaster_id field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 as_grandmaster_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_avb_info_response_set_gptp_grandmaster_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_GPTP_GRANDMASTER_ID);
}

/**
 * Extract the uint32 value of the propagation_delay field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t propagation_delay value
 */
static inline uint32_t jdksavdecc_aem_command_get_avb_info_response_get_propagation_delay(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_PROPAGATION_DELAY);
}

/**
 * Store a uint32 value to the propagation_delay field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t propagation_delay value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_propagation_delay(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_PROPAGATION_DELAY);
}

/**
 * Extract the uint8 value of the gptp_domain_number field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t gptp_domain_number value
 */
static inline uint8_t jdksavdecc_aem_command_get_avb_info_response_get_gptp_domain_number(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_GPTP_DOMAIN_NUMBER);
}

/**
 * Store a uint8 value to the gptp_domain_number field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_gptp_domain_number(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_GPTP_DOMAIN_NUMBER);
}


/**
 * Extract the uint8 value of the flags field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t flags value
 */
static inline uint8_t jdksavdecc_aem_command_get_avb_info_response_get_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_FLAGS);
}

/**
 * Store a uint8 value to the flags field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_flags(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_FLAGS);
}

/**
 * Extract the uint16 value of the msrp_mappings_count field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t msrp_mappings_count value
 */
static inline uint16_t jdksavdecc_aem_command_get_avb_info_response_get_msrp_mappings_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_MSRP_MAPPINGS_COUNT);
}

/**
 * Store a uint16 value to the msrp_mappings_count field of the
 *COMMAND_GET_AVB_INFO_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t msrp_mappings_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_avb_info_response_set_msrp_mappings_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_OFFSET_MSRP_MAPPINGS_COUNT);
}

/*@}*/

/** \addtogroup command_get_avb_info_response GET_AVB_INFO Response  - Clause 7.4.40.2 */
/*@{*/

/// GET_AVB_INFO Response  - Clause 7.4.40.2
struct jdksavdecc_aem_command_get_avb_info_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 gptp_grandmaster_id;
    uint32_t propagation_delay;
    uint8_t gptp_domain_number;
    uint8_t flags;
    uint16_t msrp_mappings_count;
};

/**
 * Extract the jdksavdecc_aem_command_get_avb_info_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_avb_info_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_avb_info_response_read(struct jdksavdecc_aem_command_get_avb_info_response *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_avb_info_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_avb_info_response_get_descriptor_index(base, pos);
        p->gptp_grandmaster_id = jdksavdecc_aem_command_get_avb_info_response_get_gptp_grandmaster_id(base, pos);
        p->propagation_delay = jdksavdecc_aem_command_get_avb_info_response_get_propagation_delay(base, pos);
        p->gptp_domain_number = jdksavdecc_aem_command_get_avb_info_response_get_gptp_domain_number(base, pos);
        p->flags = jdksavdecc_aem_command_get_avb_info_response_get_flags(base, pos);
        p->msrp_mappings_count = jdksavdecc_aem_command_get_avb_info_response_get_msrp_mappings_count(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_avb_info_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_avb_info_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_avb_info_response_write(
    struct jdksavdecc_aem_command_get_avb_info_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AVB_INFO_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_avb_info_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_avb_info_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_avb_info_response_set_gptp_grandmaster_id(p->gptp_grandmaster_id, base, pos);
        jdksavdecc_aem_command_get_avb_info_response_set_propagation_delay(p->propagation_delay, base, pos);
        jdksavdecc_aem_command_get_avb_info_response_set_gptp_domain_number(p->gptp_domain_number, base, pos);
        jdksavdecc_aem_command_get_avb_info_response_set_flags(p->flags, base, pos);
        jdksavdecc_aem_command_get_avb_info_response_set_msrp_mappings_count(p->msrp_mappings_count, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_as_path GET_AS_PATH Command  - Clause 7.4.41.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_AS_PATH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_as_path_get_controller_entity_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_AS_PATH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_as_path_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_AS_PATH
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_AS_PATH
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_GET_AS_PATH
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_AS_PATH
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_AS_PATH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_GET_AS_PATH
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_GET_AS_PATH
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_GET_AS_PATH object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_as_path GET_AS_PATH Command  - Clause 7.4.41.1 */
/*@{*/

/// GET_AS_PATH Command  - Clause 7.4.41.1
struct jdksavdecc_aem_command_get_as_path {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_as_path structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_as_path structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_as_path_read(struct jdksavdecc_aem_command_get_as_path *p,
                                                              void const *base,
                                                              ssize_t pos,
                                                              size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_index = jdksavdecc_aem_command_get_as_path_get_descriptor_index(base, pos);
        p->reserved = jdksavdecc_aem_command_get_as_path_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_as_path structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_as_path structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_as_path_write(struct jdksavdecc_aem_command_get_as_path const *p,
                                                               void *base,
                                                               size_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_as_path_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_as_path_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_as_path_response GET_AS_PATH Response  - Clause 7.4.41.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_AS_PATH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_as_path_response_get_controller_entity_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_AS_PATH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_as_path_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_AS_PATH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_AS_PATH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_AS_PATH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_AS_PATH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_AS_PATH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_AS_PATH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_GET_AS_PATH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_as_path_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_GET_AS_PATH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_as_path_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_as_path_response GET_AS_PATH Response  - Clause 7.4.41.2 */
/*@{*/

/// GET_AS_PATH Response  - Clause 7.4.41.2
struct jdksavdecc_aem_command_get_as_path_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_as_path_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_as_path_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_as_path_response_read(struct jdksavdecc_aem_command_get_as_path_response *p,
                                                                       void const *base,
                                                                       ssize_t pos,
                                                                       size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_index = jdksavdecc_aem_command_get_as_path_response_get_descriptor_index(base, pos);
        p->reserved = jdksavdecc_aem_command_get_as_path_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_as_path_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_as_path_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_as_path_response_write(
    struct jdksavdecc_aem_command_get_as_path_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AS_PATH_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_as_path_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_as_path_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_counters GET_COUNTERS Command  - Clause 7.4.42.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_COUNTERS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_counters_get_controller_entity_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_COUNTERS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_counters_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_GET_COUNTERS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_COUNTERS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_COUNTERS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_COUNTERS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_COUNTERS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_GET_COUNTERS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_COUNTERS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_COUNTERS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_get_counters GET_COUNTERS Command  - Clause 7.4.42.1 */
/*@{*/

/// GET_COUNTERS Command  - Clause 7.4.42.1
struct jdksavdecc_aem_command_get_counters {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_counters structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_counters structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_counters_read(struct jdksavdecc_aem_command_get_counters *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_counters_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_counters_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_counters structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_counters structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_counters_write(struct jdksavdecc_aem_command_get_counters const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_counters_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_counters_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_counters_response GET_COUNTERS Response  - Clause 7.4.42.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_COUNTERS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_counters_response_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_COUNTERS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_counters_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_COUNTERS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_COUNTERS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_COUNTERS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_COUNTERS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_COUNTERS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_COUNTERS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_COUNTERS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_counters_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_COUNTERS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint32 value of the counters_valid field of the
 *COMMAND_GET_COUNTERS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t counters_valid value
 */
static inline uint32_t jdksavdecc_aem_command_get_counters_response_get_counters_valid(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COUNTERS_VALID);
}

/**
 * Store a uint32 value to the counters_valid field of the
 *COMMAND_GET_COUNTERS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t counters_valid value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_counters_response_set_counters_valid(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_OFFSET_COUNTERS_VALID);
}

/*@}*/

/** \addtogroup command_get_counters_response GET_COUNTERS Response  - Clause 7.4.42.2 */
/*@{*/

/// GET_COUNTERS Response  - Clause 7.4.42.2
struct jdksavdecc_aem_command_get_counters_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint32_t counters_valid;
};

/**
 * Extract the jdksavdecc_aem_command_get_counters_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_counters_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_counters_response_read(struct jdksavdecc_aem_command_get_counters_response *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_counters_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_counters_response_get_descriptor_index(base, pos);
        p->counters_valid = jdksavdecc_aem_command_get_counters_response_get_counters_valid(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_counters_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_counters_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_counters_response_write(
    struct jdksavdecc_aem_command_get_counters_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_COUNTERS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_counters_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_counters_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_counters_response_set_counters_valid(p->counters_valid, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_reboot REBOOT Command  - Clause 7.4.43.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REBOOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_reboot_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the COMMAND_REBOOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_REBOOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_REBOOT object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the COMMAND_REBOOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_REBOOT object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the COMMAND_REBOOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_REBOOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the COMMAND_REBOOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the COMMAND_REBOOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_reboot REBOOT Command  - Clause 7.4.43.1 */
/*@{*/

/// REBOOT Command  - Clause 7.4.43.1
struct jdksavdecc_aem_command_reboot {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_reboot structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_reboot structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_reboot_read(struct jdksavdecc_aem_command_reboot *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_reboot_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_reboot_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_reboot structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_reboot structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_aem_command_reboot_write(struct jdksavdecc_aem_command_reboot const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REBOOT_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_reboot_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_reboot_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_reboot_response REBOOT Response - Clause 7.4.43.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REBOOT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_reboot_response_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REBOOT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_reboot_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REBOOT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_REBOOT_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REBOOT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_REBOOT_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REBOOT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REBOOT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REBOOT_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_reboot_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REBOOT_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_reboot_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_reboot_response REBOOT Response - Clause 7.4.43.1 */
/*@{*/

/// REBOOT Response - Clause 7.4.43.1
struct jdksavdecc_aem_command_reboot_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_reboot_response structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_reboot_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_reboot_response_read(struct jdksavdecc_aem_command_reboot_response *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_reboot_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_reboot_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_reboot_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_reboot_response structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_reboot_response_write(struct jdksavdecc_aem_command_reboot_response const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REBOOT_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_reboot_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_reboot_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_audio_map GET_AUDIO_MAP Command  - Clause 7.4.44.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_audio_map_get_controller_entity_id(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_AUDIO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_audio_map_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_AUDIO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_AUDIO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_AUDIO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_AUDIO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the map_index field of the COMMAND_GET_AUDIO_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t map_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_get_map_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_MAP_INDEX);
}

/**
 * Store a uint16 value to the map_index field of the COMMAND_GET_AUDIO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t map_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_set_map_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_MAP_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_GET_AUDIO_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_GET_AUDIO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_audio_map GET_AUDIO_MAP Command  - Clause 7.4.44.1
 */
/*@{*/

/// GET_AUDIO_MAP Command  - Clause 7.4.44.1
struct jdksavdecc_aem_command_get_audio_map {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t map_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_audio_map structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_audio_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_audio_map_read(struct jdksavdecc_aem_command_get_audio_map *p,
                                                                void const *base,
                                                                ssize_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_audio_map_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_audio_map_get_descriptor_index(base, pos);
        p->map_index = jdksavdecc_aem_command_get_audio_map_get_map_index(base, pos);
        p->reserved = jdksavdecc_aem_command_get_audio_map_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_audio_map structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_audio_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_audio_map_write(struct jdksavdecc_aem_command_get_audio_map const *p,
                                                                 void *base,
                                                                 size_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_audio_map_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_audio_map_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_audio_map_set_map_index(p->map_index, base, pos);
        jdksavdecc_aem_command_get_audio_map_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_audio_map_response GET_AUDIO_MAP Response  - Clause 7.4.44.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_audio_map_response_get_controller_entity_id(void const *base,
                                                                                                             ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_audio_map_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the map_index field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t map_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_map_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_MAP_INDEX);
}

/**
 * Store a uint16 value to the map_index field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t map_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_map_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_MAP_INDEX);
}

/**
 * Extract the uint16 value of the number_of_maps field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_maps value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_number_of_maps(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Store a uint16 value to the number_of_maps field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_maps value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_number_of_maps(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_audio_map_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_GET_AUDIO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_audio_map_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_audio_map_response GET_AUDIO_MAP Response  - Clause 7.4.44.2 */
/*@{*/

/// GET_AUDIO_MAP Response  - Clause 7.4.44.2
struct jdksavdecc_aem_command_get_audio_map_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t map_index;
    uint16_t number_of_maps;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_audio_map_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_audio_map_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_audio_map_response_read(
    struct jdksavdecc_aem_command_get_audio_map_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_audio_map_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_audio_map_response_get_descriptor_index(base, pos);
        p->map_index = jdksavdecc_aem_command_get_audio_map_response_get_map_index(base, pos);
        p->number_of_maps = jdksavdecc_aem_command_get_audio_map_response_get_number_of_maps(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_get_audio_map_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_get_audio_map_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_audio_map_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_audio_map_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_audio_map_response_write(
    struct jdksavdecc_aem_command_get_audio_map_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_AUDIO_MAP_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_audio_map_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_audio_map_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_audio_map_response_set_map_index(p->map_index, base, pos);
        jdksavdecc_aem_command_get_audio_map_response_set_number_of_maps(p->number_of_maps, base, pos);
        jdksavdecc_aem_command_get_audio_map_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_get_audio_map_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_add_audio_mappings ADD_AUDIO_MAPPINGS Command  - Clause 7.4.45.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_add_audio_mappings_get_controller_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_audio_mappings_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ADD_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_ADD_AUDIO_MAPPINGS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_add_audio_mappings ADD_AUDIO_MAPPINGS Command  - Clause 7.4.45.1 */
/*@{*/

/// ADD_AUDIO_MAPPINGS Command  - Clause 7.4.45.1
struct jdksavdecc_aem_command_add_audio_mappings {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_add_audio_mappings structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_add_audio_mappings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_audio_mappings_read(struct jdksavdecc_aem_command_add_audio_mappings *p,
                                                                     void const *base,
                                                                     ssize_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_add_audio_mappings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_add_audio_mappings_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_add_audio_mappings_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_add_audio_mappings_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_add_audio_mappings structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_add_audio_mappings structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_audio_mappings_write(struct jdksavdecc_aem_command_add_audio_mappings const *p,
                                                                      void *base,
                                                                      size_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_add_audio_mappings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_add_audio_mappings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_add_audio_mappings_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_add_audio_mappings_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_add_audio_mappings_response ADD_AUDIO_MAPPINGS Response
 * - Clause 7.4.45.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_add_audio_mappings_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                               void *base,
                                                                                               ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_audio_mappings_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_response_get_number_of_mappings(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_audio_mappings_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_add_audio_mappings_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_audio_mappings_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_add_audio_mappings_response ADD_AUDIO_MAPPINGS Response
 * - Clause 7.4.45.1 */
/*@{*/

/// ADD_AUDIO_MAPPINGS Response  - Clause 7.4.45.1
struct jdksavdecc_aem_command_add_audio_mappings_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_add_audio_mappings_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_add_audio_mappings_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_audio_mappings_response_read(
    struct jdksavdecc_aem_command_add_audio_mappings_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_add_audio_mappings_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_add_audio_mappings_response_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_add_audio_mappings_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_add_audio_mappings_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_add_audio_mappings_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_add_audio_mappings_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_audio_mappings_response_write(
    struct jdksavdecc_aem_command_add_audio_mappings_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_AUDIO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_add_audio_mappings_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_add_audio_mappings_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_add_audio_mappings_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_add_audio_mappings_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_remove_audio_mappings REMOVE_AUDIO_MAPPINGS Command  -
 * Clause 7.4.46.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_remove_audio_mappings_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_audio_mappings_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_remove_audio_mappings REMOVE_AUDIO_MAPPINGS Command  -
 * Clause 7.4.46.1 */
/*@{*/

/// REMOVE_AUDIO_MAPPINGS Command  - Clause 7.4.46.1
struct jdksavdecc_aem_command_remove_audio_mappings {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_remove_audio_mappings structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_remove_audio_mappings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_audio_mappings_read(struct jdksavdecc_aem_command_remove_audio_mappings *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_remove_audio_mappings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_remove_audio_mappings_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_remove_audio_mappings_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_remove_audio_mappings_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_remove_audio_mappings structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_remove_audio_mappings structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_audio_mappings_write(
    struct jdksavdecc_aem_command_remove_audio_mappings const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_remove_audio_mappings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_remove_audio_mappings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_remove_audio_mappings_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_remove_audio_mappings_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_remove_audio_mappings_response REMOVE_AUDIO_MAPPINGS
 * Response  - Clause 7.4.46.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_remove_audio_mappings_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                  void *base,
                                                                                                  ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_response_get_descriptor_type(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_audio_mappings_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_response_get_descriptor_index(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_audio_mappings_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_response_get_number_of_mappings(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_audio_mappings_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_remove_audio_mappings_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_audio_mappings_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_remove_audio_mappings_response REMOVE_AUDIO_MAPPINGS
 * Response  - Clause 7.4.46.1 */
/*@{*/

/// REMOVE_AUDIO_MAPPINGS Response  - Clause 7.4.46.1
struct jdksavdecc_aem_command_remove_audio_mappings_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_remove_audio_mappings_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_remove_audio_mappings_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_audio_mappings_response_read(
    struct jdksavdecc_aem_command_remove_audio_mappings_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_remove_audio_mappings_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_remove_audio_mappings_response_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_remove_audio_mappings_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_remove_audio_mappings_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_remove_audio_mappings_response structure to
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_remove_audio_mappings_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_audio_mappings_response_write(
    struct jdksavdecc_aem_command_remove_audio_mappings_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_AUDIO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_remove_audio_mappings_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_remove_audio_mappings_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_remove_audio_mappings_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_remove_audio_mappings_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_video_map GET_VIDEO_MAP Command  - Clause 7.4.47.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_video_map_get_controller_entity_id(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_VIDEO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_video_map_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_VIDEO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_VIDEO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_VIDEO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_VIDEO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the map_index field of the COMMAND_GET_VIDEO_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t map_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_get_map_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_MAP_INDEX);
}

/**
 * Store a uint16 value to the map_index field of the COMMAND_GET_VIDEO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t map_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_set_map_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_MAP_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_GET_VIDEO_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_GET_VIDEO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_video_map GET_VIDEO_MAP Command  - Clause 7.4.47.1
 */
/*@{*/

/// GET_VIDEO_MAP Command  - Clause 7.4.47.1
struct jdksavdecc_aem_command_get_video_map {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t map_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_video_map structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_video_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_map_read(struct jdksavdecc_aem_command_get_video_map *p,
                                                                void const *base,
                                                                ssize_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_video_map_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_video_map_get_descriptor_index(base, pos);
        p->map_index = jdksavdecc_aem_command_get_video_map_get_map_index(base, pos);
        p->reserved = jdksavdecc_aem_command_get_video_map_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_video_map structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_video_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_map_write(struct jdksavdecc_aem_command_get_video_map const *p,
                                                                 void *base,
                                                                 size_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_video_map_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_video_map_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_video_map_set_map_index(p->map_index, base, pos);
        jdksavdecc_aem_command_get_video_map_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_video_map_response GET_VIDEO_MAP Response  - Clause 7.4.47.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_video_map_response_get_controller_entity_id(void const *base,
                                                                                                             ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_video_map_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the map_index field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t map_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_map_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_MAP_INDEX);
}

/**
 * Store a uint16 value to the map_index field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t map_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_map_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_MAP_INDEX);
}

/**
 * Extract the uint16 value of the number_of_maps field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_maps value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_number_of_maps(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Store a uint16 value to the number_of_maps field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_maps value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_number_of_maps(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_video_map_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_GET_VIDEO_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_video_map_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_video_map_response GET_VIDEO_MAP Response  - Clause 7.4.47.2 */
/*@{*/

/// GET_VIDEO_MAP Response  - Clause 7.4.47.2
struct jdksavdecc_aem_command_get_video_map_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t map_index;
    uint16_t number_of_maps;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_video_map_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_video_map_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_map_response_read(
    struct jdksavdecc_aem_command_get_video_map_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_video_map_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_video_map_response_get_descriptor_index(base, pos);
        p->map_index = jdksavdecc_aem_command_get_video_map_response_get_map_index(base, pos);
        p->number_of_maps = jdksavdecc_aem_command_get_video_map_response_get_number_of_maps(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_get_video_map_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_get_video_map_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_video_map_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_video_map_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_video_map_response_write(
    struct jdksavdecc_aem_command_get_video_map_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_VIDEO_MAP_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_video_map_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_video_map_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_video_map_response_set_map_index(p->map_index, base, pos);
        jdksavdecc_aem_command_get_video_map_response_set_number_of_maps(p->number_of_maps, base, pos);
        jdksavdecc_aem_command_get_video_map_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_get_video_map_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_add_video_mappings ADD_VIDEO_MAPPINGS Command  - Clause 7.4.48.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_add_video_mappings_get_controller_entity_id(void const *base,
                                                                                                         ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_video_mappings_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ADD_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_ADD_VIDEO_MAPPINGS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_add_video_mappings ADD_VIDEO_MAPPINGS Command  - Clause 7.4.48.1 */
/*@{*/

/// ADD_VIDEO_MAPPINGS Command  - Clause 7.4.48.1
struct jdksavdecc_aem_command_add_video_mappings {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_add_video_mappings structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_add_video_mappings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_video_mappings_read(struct jdksavdecc_aem_command_add_video_mappings *p,
                                                                     void const *base,
                                                                     ssize_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_add_video_mappings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_add_video_mappings_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_add_video_mappings_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_add_video_mappings_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_add_video_mappings structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_add_video_mappings structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_video_mappings_write(struct jdksavdecc_aem_command_add_video_mappings const *p,
                                                                      void *base,
                                                                      size_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_add_video_mappings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_add_video_mappings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_add_video_mappings_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_add_video_mappings_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_add_video_mappings_response ADD_VIDEO_MAPPINGS Response
 * - Clause 7.4.48.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_add_video_mappings_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                               void *base,
                                                                                               ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_video_mappings_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_response_get_number_of_mappings(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_video_mappings_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_add_video_mappings_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_video_mappings_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_add_video_mappings_response ADD_VIDEO_MAPPINGS Response
 * - Clause 7.4.48.1 */
/*@{*/

/// ADD_VIDEO_MAPPINGS Response  - Clause 7.4.48.1
struct jdksavdecc_aem_command_add_video_mappings_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_add_video_mappings_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_add_video_mappings_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_video_mappings_response_read(
    struct jdksavdecc_aem_command_add_video_mappings_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_add_video_mappings_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_add_video_mappings_response_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_add_video_mappings_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_add_video_mappings_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_add_video_mappings_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_add_video_mappings_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_video_mappings_response_write(
    struct jdksavdecc_aem_command_add_video_mappings_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_VIDEO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_add_video_mappings_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_add_video_mappings_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_add_video_mappings_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_add_video_mappings_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_remove_video_mappings REMOVE_VIDEO_MAPPINGS Command  -
 * Clause 7.4.49.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_remove_video_mappings_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_video_mappings_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_remove_video_mappings REMOVE_VIDEO_MAPPINGS Command  -
 * Clause 7.4.49.1 */
/*@{*/

/// REMOVE_VIDEO_MAPPINGS Command  - Clause 7.4.49.1
struct jdksavdecc_aem_command_remove_video_mappings {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_remove_video_mappings structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_remove_video_mappings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_video_mappings_read(struct jdksavdecc_aem_command_remove_video_mappings *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_remove_video_mappings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_remove_video_mappings_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_remove_video_mappings_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_remove_video_mappings_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_remove_video_mappings structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_remove_video_mappings structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_video_mappings_write(
    struct jdksavdecc_aem_command_remove_video_mappings const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_remove_video_mappings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_remove_video_mappings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_remove_video_mappings_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_remove_video_mappings_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_remove_video_mappings_response REMOVE_VIDEO_MAPPINGS
 * Response  - Clause 7.4.49.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_remove_video_mappings_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                  void *base,
                                                                                                  ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_response_get_descriptor_type(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_video_mappings_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_response_get_descriptor_index(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_video_mappings_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_response_get_number_of_mappings(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_video_mappings_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_remove_video_mappings_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_video_mappings_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_remove_video_mappings_response REMOVE_VIDEO_MAPPINGS
 * Response  - Clause 7.4.49.1 */
/*@{*/

/// REMOVE_VIDEO_MAPPINGS Response  - Clause 7.4.49.1
struct jdksavdecc_aem_command_remove_video_mappings_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_remove_video_mappings_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_remove_video_mappings_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_video_mappings_response_read(
    struct jdksavdecc_aem_command_remove_video_mappings_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_remove_video_mappings_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_remove_video_mappings_response_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_remove_video_mappings_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_remove_video_mappings_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_remove_video_mappings_response structure to
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_remove_video_mappings_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_video_mappings_response_write(
    struct jdksavdecc_aem_command_remove_video_mappings_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_VIDEO_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_remove_video_mappings_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_remove_video_mappings_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_remove_video_mappings_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_remove_video_mappings_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_sensor_map GET_SENSOR_MAP Command  - Clause 7.4.50.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_sensor_map_get_controller_entity_id(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sensor_map_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_GET_SENSOR_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_GET_SENSOR_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the map_index field of the COMMAND_GET_SENSOR_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t map_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_get_map_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_MAP_INDEX);
}

/**
 * Store a uint16 value to the map_index field of the COMMAND_GET_SENSOR_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t map_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_set_map_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_MAP_INDEX);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_GET_SENSOR_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_GET_SENSOR_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_sensor_map GET_SENSOR_MAP Command  - Clause 7.4.50.1
 */
/*@{*/

/// GET_SENSOR_MAP Command  - Clause 7.4.50.1
struct jdksavdecc_aem_command_get_sensor_map {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t map_index;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_sensor_map structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_sensor_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_map_read(struct jdksavdecc_aem_command_get_sensor_map *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_sensor_map_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_sensor_map_get_descriptor_index(base, pos);
        p->map_index = jdksavdecc_aem_command_get_sensor_map_get_map_index(base, pos);
        p->reserved = jdksavdecc_aem_command_get_sensor_map_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_sensor_map structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_sensor_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_map_write(struct jdksavdecc_aem_command_get_sensor_map const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_sensor_map_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_sensor_map_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_sensor_map_set_map_index(p->map_index, base, pos);
        jdksavdecc_aem_command_get_sensor_map_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_sensor_map_response GET_SENSOR_MAP Response  -
 * Clause 7.4.50.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_sensor_map_response_get_controller_entity_id(void const *base,
                                                                                                              ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_sensor_map_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the map_index field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t map_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_map_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_MAP_INDEX);
}

/**
 * Store a uint16 value to the map_index field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t map_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_map_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_MAP_INDEX);
}

/**
 * Extract the uint16 value of the number_of_maps field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_maps value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_number_of_maps(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Store a uint16 value to the number_of_maps field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_maps value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_number_of_maps(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_get_sensor_map_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_GET_SENSOR_MAP_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_sensor_map_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_get_sensor_map_response GET_SENSOR_MAP Response  -
 * Clause 7.4.50.2 */
/*@{*/

/// GET_SENSOR_MAP Response  - Clause 7.4.50.2
struct jdksavdecc_aem_command_get_sensor_map_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t map_index;
    uint16_t number_of_maps;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_get_sensor_map_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_sensor_map_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_map_response_read(
    struct jdksavdecc_aem_command_get_sensor_map_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_sensor_map_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_sensor_map_response_get_descriptor_index(base, pos);
        p->map_index = jdksavdecc_aem_command_get_sensor_map_response_get_map_index(base, pos);
        p->number_of_maps = jdksavdecc_aem_command_get_sensor_map_response_get_number_of_maps(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_get_sensor_map_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_get_sensor_map_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_sensor_map_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_sensor_map_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_sensor_map_response_write(
    struct jdksavdecc_aem_command_get_sensor_map_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_SENSOR_MAP_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_sensor_map_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_sensor_map_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_sensor_map_response_set_map_index(p->map_index, base, pos);
        jdksavdecc_aem_command_get_sensor_map_response_set_number_of_maps(p->number_of_maps, base, pos);
        jdksavdecc_aem_command_get_sensor_map_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_get_sensor_map_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_add_sensor_mappings ADD_SENSOR_MAPPINGS Command  -
 * Clause 7.4.51.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_add_sensor_mappings_get_controller_entity_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_sensor_mappings_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ADD_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_ADD_SENSOR_MAPPINGS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_add_sensor_mappings ADD_SENSOR_MAPPINGS Command  -
 * Clause 7.4.51.1 */
/*@{*/

/// ADD_SENSOR_MAPPINGS Command  - Clause 7.4.51.1
struct jdksavdecc_aem_command_add_sensor_mappings {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_add_sensor_mappings structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_add_sensor_mappings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_sensor_mappings_read(struct jdksavdecc_aem_command_add_sensor_mappings *p,
                                                                      void const *base,
                                                                      ssize_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_add_sensor_mappings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_add_sensor_mappings_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_add_sensor_mappings_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_add_sensor_mappings_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_add_sensor_mappings structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_add_sensor_mappings structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_sensor_mappings_write(
    struct jdksavdecc_aem_command_add_sensor_mappings const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_add_sensor_mappings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_add_sensor_mappings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_add_sensor_mappings_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_add_sensor_mappings_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_add_sensor_mappings_response ADD_SENSOR_MAPPINGS
 * Response  - Clause 7.4.51.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_add_sensor_mappings_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                void *base,
                                                                                                ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_sensor_mappings_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_sensor_mappings_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_response_get_number_of_mappings(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_add_sensor_mappings_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_add_sensor_mappings_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_add_sensor_mappings_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_add_sensor_mappings_response ADD_SENSOR_MAPPINGS
 * Response  - Clause 7.4.51.1 */
/*@{*/

/// ADD_SENSOR_MAPPINGS Response  - Clause 7.4.51.1
struct jdksavdecc_aem_command_add_sensor_mappings_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_add_sensor_mappings_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_add_sensor_mappings_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_sensor_mappings_response_read(
    struct jdksavdecc_aem_command_add_sensor_mappings_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_add_sensor_mappings_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_add_sensor_mappings_response_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_add_sensor_mappings_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_add_sensor_mappings_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_add_sensor_mappings_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_add_sensor_mappings_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_add_sensor_mappings_response_write(
    struct jdksavdecc_aem_command_add_sensor_mappings_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ADD_SENSOR_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_add_sensor_mappings_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_add_sensor_mappings_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_add_sensor_mappings_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_add_sensor_mappings_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_remove_sensor_mappings REMOVE_SENSOR_MAPPINGS Command  -
 * Clause 7.4.52.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_remove_sensor_mappings_get_controller_entity_id(void const *base,
                                                                                                             ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_sensor_mappings_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_remove_sensor_mappings REMOVE_SENSOR_MAPPINGS Command  -
 * Clause 7.4.52.1 */
/*@{*/

/// REMOVE_SENSOR_MAPPINGS Command  - Clause 7.4.52.1
struct jdksavdecc_aem_command_remove_sensor_mappings {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_remove_sensor_mappings structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_remove_sensor_mappings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_sensor_mappings_read(
    struct jdksavdecc_aem_command_remove_sensor_mappings *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_remove_sensor_mappings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_remove_sensor_mappings_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_remove_sensor_mappings_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_remove_sensor_mappings_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_remove_sensor_mappings structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_remove_sensor_mappings structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_sensor_mappings_write(
    struct jdksavdecc_aem_command_remove_sensor_mappings const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_remove_sensor_mappings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_remove_sensor_mappings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_remove_sensor_mappings_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_remove_sensor_mappings_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_remove_sensor_mappings_response REMOVE_SENSOR_MAPPINGS
 * Response  - Clause 7.4.52.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_remove_sensor_mappings_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                   void *base,
                                                                                                   ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_sensor_mappings_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_response_get_descriptor_type(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_sensor_mappings_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_response_get_descriptor_index(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_sensor_mappings_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_response_get_number_of_mappings(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_remove_sensor_mappings_response_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_remove_sensor_mappings_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_remove_sensor_mappings_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_remove_sensor_mappings_response REMOVE_SENSOR_MAPPINGS
 * Response  - Clause 7.4.52.1 */
/*@{*/

/// REMOVE_SENSOR_MAPPINGS Response  - Clause 7.4.52.1
struct jdksavdecc_aem_command_remove_sensor_mappings_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t number_of_mappings;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_remove_sensor_mappings_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_remove_sensor_mappings_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_sensor_mappings_response_read(
    struct jdksavdecc_aem_command_remove_sensor_mappings_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_remove_sensor_mappings_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_remove_sensor_mappings_response_get_descriptor_index(base, pos);
        p->number_of_mappings = jdksavdecc_aem_command_remove_sensor_mappings_response_get_number_of_mappings(base, pos);
        p->reserved = jdksavdecc_aem_command_remove_sensor_mappings_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_remove_sensor_mappings_response structure to
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_remove_sensor_mappings_response structure
 *to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_remove_sensor_mappings_response_write(
    struct jdksavdecc_aem_command_remove_sensor_mappings_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_REMOVE_SENSOR_MAPPINGS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_remove_sensor_mappings_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_remove_sensor_mappings_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_remove_sensor_mappings_response_set_number_of_mappings(p->number_of_mappings, base, pos);
        jdksavdecc_aem_command_remove_sensor_mappings_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_start_operation START_OPERATION Command  - Clause 7.4.53.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_start_operation_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_START_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_start_operation_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_START_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_START_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_START_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_START_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the operation_id field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_id value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_get_operation_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_OPERATION_ID);
}

/**
 * Store a uint16 value to the operation_id field of the COMMAND_START_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_set_operation_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_OPERATION_ID);
}

/**
 * Extract the uint16 value of the operation_type field of the
 *COMMAND_START_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_get_operation_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_OPERATION_TYPE);
}

/**
 * Store a uint16 value to the operation_type field of the
 *COMMAND_START_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_set_operation_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_OFFSET_OPERATION_TYPE);
}

/*@}*/

/** \addtogroup command_start_operation START_OPERATION Command  - Clause 7.4.53.1 */
/*@{*/

/// START_OPERATION Command  - Clause 7.4.53.1
struct jdksavdecc_aem_command_start_operation {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t operation_id;
    uint16_t operation_type;
};

/**
 * Extract the jdksavdecc_aem_command_start_operation structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_start_operation structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_operation_read(struct jdksavdecc_aem_command_start_operation *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_start_operation_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_start_operation_get_descriptor_index(base, pos);
        p->operation_id = jdksavdecc_aem_command_start_operation_get_operation_id(base, pos);
        p->operation_type = jdksavdecc_aem_command_start_operation_get_operation_type(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_start_operation structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_start_operation structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_operation_write(struct jdksavdecc_aem_command_start_operation const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_OPERATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_start_operation_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_start_operation_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_start_operation_set_operation_id(p->operation_id, base, pos);
        jdksavdecc_aem_command_start_operation_set_operation_type(p->operation_type, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_start_operation_response START_OPERATION Response  -
 * Clause 7.4.53.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_start_operation_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_start_operation_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the operation_id field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_id value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_response_get_operation_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_OPERATION_ID);
}

/**
 * Store a uint16 value to the operation_id field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_response_set_operation_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_OPERATION_ID);
}

/**
 * Extract the uint16 value of the operation_type field of the
 *COMMAND_START_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_type value
 */
static inline uint16_t jdksavdecc_aem_command_start_operation_response_get_operation_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_OPERATION_TYPE);
}

/**
 * Store a uint16 value to the operation_type field of the
 *COMMAND_START_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_start_operation_response_set_operation_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_OFFSET_OPERATION_TYPE);
}

/*@}*/

/** \addtogroup command_start_operation_response START_OPERATION Response  -
 * Clause 7.4.53.1 */
/*@{*/

/// START_OPERATION Response  - Clause 7.4.53.1
struct jdksavdecc_aem_command_start_operation_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t operation_id;
    uint16_t operation_type;
};

/**
 * Extract the jdksavdecc_aem_command_start_operation_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_start_operation_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_operation_response_read(
    struct jdksavdecc_aem_command_start_operation_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_start_operation_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_start_operation_response_get_descriptor_index(base, pos);
        p->operation_id = jdksavdecc_aem_command_start_operation_response_get_operation_id(base, pos);
        p->operation_type = jdksavdecc_aem_command_start_operation_response_get_operation_type(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_start_operation_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_start_operation_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_start_operation_response_write(
    struct jdksavdecc_aem_command_start_operation_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_START_OPERATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_start_operation_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_start_operation_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_start_operation_response_set_operation_id(p->operation_id, base, pos);
        jdksavdecc_aem_command_start_operation_response_set_operation_type(p->operation_type, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_abort_operation ABORT_OPERATION Command  - Clause 7.4.54.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ABORT_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_abort_operation_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ABORT_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_abort_operation_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ABORT_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_ABORT_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ABORT_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_ABORT_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ABORT_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ABORT_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ABORT_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ABORT_OPERATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the operation_id field of the
 *COMMAND_ABORT_OPERATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_id value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_get_operation_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_OPERATION_ID);
}

/**
 * Store a uint16 value to the operation_id field of the COMMAND_ABORT_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_set_operation_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_OPERATION_ID);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_ABORT_OPERATION
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_ABORT_OPERATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_abort_operation ABORT_OPERATION Command  - Clause 7.4.54.1 */
/*@{*/

/// ABORT_OPERATION Command  - Clause 7.4.54.1
struct jdksavdecc_aem_command_abort_operation {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t operation_id;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_abort_operation structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_abort_operation structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_abort_operation_read(struct jdksavdecc_aem_command_abort_operation *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_abort_operation_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_abort_operation_get_descriptor_index(base, pos);
        p->operation_id = jdksavdecc_aem_command_abort_operation_get_operation_id(base, pos);
        p->reserved = jdksavdecc_aem_command_abort_operation_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_abort_operation structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_abort_operation structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_abort_operation_write(struct jdksavdecc_aem_command_abort_operation const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_abort_operation_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_abort_operation_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_abort_operation_set_operation_id(p->operation_id, base, pos);
        jdksavdecc_aem_command_abort_operation_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_abort_operation_response ABORT_OPERATION Response  -
 * Clause 7.4.54.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_abort_operation_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_abort_operation_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the operation_id field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_id value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_response_get_operation_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_OPERATION_ID);
}

/**
 * Store a uint16 value to the operation_id field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_response_set_operation_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_OPERATION_ID);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_abort_operation_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_ABORT_OPERATION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_abort_operation_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_abort_operation_response ABORT_OPERATION Response  -
 * Clause 7.4.54.1 */
/*@{*/

/// ABORT_OPERATION Response  - Clause 7.4.54.1
struct jdksavdecc_aem_command_abort_operation_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t operation_id;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_abort_operation_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_abort_operation_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_abort_operation_response_read(
    struct jdksavdecc_aem_command_abort_operation_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_abort_operation_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_abort_operation_response_get_descriptor_index(base, pos);
        p->operation_id = jdksavdecc_aem_command_abort_operation_response_get_operation_id(base, pos);
        p->reserved = jdksavdecc_aem_command_abort_operation_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_abort_operation_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_abort_operation_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_abort_operation_response_write(
    struct jdksavdecc_aem_command_abort_operation_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ABORT_OPERATION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_abort_operation_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_abort_operation_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_abort_operation_response_set_operation_id(p->operation_id, base, pos);
        jdksavdecc_aem_command_abort_operation_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_operation_status_response OPERATION_STATUS Unsolicited
 * Response  - Clause 7.4.55.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_operation_status_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_operation_status_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_operation_status_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_operation_status_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_operation_status_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_operation_status_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_operation_status_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_operation_status_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_operation_status_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_operation_status_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the operation_id field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t operation_id value
 */
static inline uint16_t jdksavdecc_aem_command_operation_status_response_get_operation_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_OPERATION_ID);
}

/**
 * Store a uint16 value to the operation_id field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t operation_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_operation_status_response_set_operation_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_OPERATION_ID);
}

/**
 * Extract the uint16 value of the percent_complete field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t percent_complete value
 */
static inline uint16_t jdksavdecc_aem_command_operation_status_response_get_percent_complete(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_PERCENT_COMPLETE);
}

/**
 * Store a uint16 value to the percent_complete field of the
 *COMMAND_OPERATION_STATUS_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t percent_complete value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_operation_status_response_set_percent_complete(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_OFFSET_PERCENT_COMPLETE);
}

/*@}*/

/** \addtogroup command_operation_status_response OPERATION_STATUS Unsolicited
 * Response  - Clause 7.4.55.1 */
/*@{*/

/// OPERATION_STATUS Unsolicited Response  - Clause 7.4.55.1
struct jdksavdecc_aem_command_operation_status_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t operation_id;
    uint16_t percent_complete;
};

/**
 * Extract the jdksavdecc_aem_command_operation_status_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_operation_status_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_operation_status_response_read(
    struct jdksavdecc_aem_command_operation_status_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_operation_status_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_operation_status_response_get_descriptor_index(base, pos);
        p->operation_id = jdksavdecc_aem_command_operation_status_response_get_operation_id(base, pos);
        p->percent_complete = jdksavdecc_aem_command_operation_status_response_get_percent_complete(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_operation_status_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_operation_status_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_operation_status_response_write(
    struct jdksavdecc_aem_command_operation_status_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_OPERATION_STATUS_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_operation_status_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_operation_status_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_operation_status_response_set_operation_id(p->operation_id, base, pos);
        jdksavdecc_aem_command_operation_status_response_set_percent_complete(p->percent_complete, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_add_key AUTH_ADD_KEY Command  - Clause 7.4.56.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_get_controller_entity_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_add_key_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_AUTH_ADD_KEY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_AUTH_ADD_KEY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_ADD_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_AUTH_ADD_KEY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the COMMAND_AUTH_ADD_KEY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_get_key_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the COMMAND_AUTH_ADD_KEY object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY_ID);
}

/**
 * Extract the uint16 value of the key_type_key_length field of the
 *COMMAND_AUTH_ADD_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t key_type_key_length value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_get_key_type_key_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY_TYPE_KEY_LENGTH);
}

/**
 * Store a uint16 value to the key_type_key_length field of the
 *COMMAND_AUTH_ADD_KEY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t key_type_key_length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_set_key_type_key_length(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_KEY_TYPE_KEY_LENGTH);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_AUTH_ADD_KEY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_AUTH_ADD_KEY object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_auth_add_key AUTH_ADD_KEY Command  - Clause 7.4.56.1 */
/*@{*/

/// AUTH_ADD_KEY Command  - Clause 7.4.56.1
struct jdksavdecc_aem_command_auth_add_key {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
    uint16_t key_type_key_length;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_auth_add_key structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_add_key structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_read(struct jdksavdecc_aem_command_auth_add_key *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_auth_add_key_get_key_id(base, pos);
        p->key_type_key_length = jdksavdecc_aem_command_auth_add_key_get_key_type_key_length(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_add_key_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_add_key structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_add_key structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_write(struct jdksavdecc_aem_command_auth_add_key const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_add_key_set_key_id(p->key_id, base, pos);
        jdksavdecc_aem_command_auth_add_key_set_key_type_key_length(p->key_type_key_length, base, pos);
        jdksavdecc_aem_command_auth_add_key_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_add_key_response AUTH_ADD_KEY Response  - Clause 7.4.56.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_response_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_add_key_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_ADD_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_response_get_key_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the COMMAND_AUTH_ADD_KEY_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_add_key_response AUTH_ADD_KEY Response  - Clause 7.4.56.2 */
/*@{*/

/// AUTH_ADD_KEY Response  - Clause 7.4.56.2
struct jdksavdecc_aem_command_auth_add_key_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_add_key_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_add_key_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_response_read(struct jdksavdecc_aem_command_auth_add_key_response *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_auth_add_key_response_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_add_key_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_add_key_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_response_write(
    struct jdksavdecc_aem_command_auth_add_key_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_add_key_response_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_delete_key AUTH_DELETE_KEY Command  - Clause 7.4.57.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_key_get_controller_entity_id(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_AUTH_DELETE_KEY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_DELETE_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_AUTH_DELETE_KEY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the COMMAND_AUTH_DELETE_KEY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_key_get_key_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the COMMAND_AUTH_DELETE_KEY object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_delete_key AUTH_DELETE_KEY Command  - Clause 7.4.57.1 */
/*@{*/

/// AUTH_DELETE_KEY Command  - Clause 7.4.57.1
struct jdksavdecc_aem_command_auth_delete_key {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_delete_key structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_delete_key structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_read(struct jdksavdecc_aem_command_auth_delete_key *p,
                                                                  void const *base,
                                                                  ssize_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_auth_delete_key_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_delete_key structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_delete_key structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_write(struct jdksavdecc_aem_command_auth_delete_key const *p,
                                                                   void *base,
                                                                   size_t pos,
                                                                   size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_delete_key_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_delete_key_response AUTH_DELETE_KEY Response  -
 * Clause 7.4.57.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_key_response_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_key_response_get_key_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_AUTH_DELETE_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_delete_key_response AUTH_DELETE_KEY Response  -
 * Clause 7.4.57.1 */
/*@{*/

/// AUTH_DELETE_KEY Response  - Clause 7.4.57.1
struct jdksavdecc_aem_command_auth_delete_key_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_delete_key_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_delete_key_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_response_read(
    struct jdksavdecc_aem_command_auth_delete_key_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_auth_delete_key_response_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_delete_key_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_delete_key_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_response_write(
    struct jdksavdecc_aem_command_auth_delete_key_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_delete_key_response_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_key_list AUTH_GET_KEY_LIST Command  - Clause 7.4.58.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_key_list_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_key_list_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_KEY_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_KEY_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_list_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_KEY_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_KEY_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_list_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychainid_reserved field of the
 *COMMAND_AUTH_GET_KEY_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychainid_reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_get_keychainid_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_KEYCHAINID_RESERVED);
}

/**
 * Store a uint16 value to the keychainid_reserved field of the
 *COMMAND_AUTH_GET_KEY_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychainid_reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_list_set_keychainid_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_OFFSET_KEYCHAINID_RESERVED);
}

/*@}*/

/** \addtogroup command_auth_get_key_list AUTH_GET_KEY_LIST Command  - Clause 7.4.58.1 */
/*@{*/

/// AUTH_GET_KEY_LIST Command  - Clause 7.4.58.1
struct jdksavdecc_aem_command_auth_get_key_list {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychainid_reserved;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_key_list structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_key_list structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_list_read(struct jdksavdecc_aem_command_auth_get_key_list *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychainid_reserved = jdksavdecc_aem_command_auth_get_key_list_get_keychainid_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_key_list structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_key_list structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_list_write(struct jdksavdecc_aem_command_auth_get_key_list const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_key_list_set_keychainid_reserved(p->keychainid_reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_key_list_response AUTH_GET_KEY_LIST Response  -
 * Clause 7.4.58.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_get_key_list_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_key_list_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_list_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_list_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychainid_number_of_keys field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychainid_number_of_keys value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_response_get_keychainid_number_of_keys(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_uint16_get(base,
                                 pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_KEYCHAINID_NUMBER_OF_KEYS);
}

/**
 * Store a uint16 value to the keychainid_number_of_keys field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychainid_number_of_keys value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_key_list_response_set_keychainid_number_of_keys(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_KEYCHAINID_NUMBER_OF_KEYS);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_list_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_AUTH_GET_KEY_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_list_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_auth_get_key_list_response AUTH_GET_KEY_LIST Response  -
 * Clause 7.4.58.2 */
/*@{*/

/// AUTH_GET_KEY_LIST Response  - Clause 7.4.58.2
struct jdksavdecc_aem_command_auth_get_key_list_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychainid_number_of_keys;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_key_list_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_key_list_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_list_response_read(
    struct jdksavdecc_aem_command_auth_get_key_list_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychainid_number_of_keys
            = jdksavdecc_aem_command_auth_get_key_list_response_get_keychainid_number_of_keys(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_get_key_list_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_key_list_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_key_list_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_list_response_write(
    struct jdksavdecc_aem_command_auth_get_key_list_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_LIST_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_key_list_response_set_keychainid_number_of_keys(
            p->keychainid_number_of_keys, base, pos);
        jdksavdecc_aem_command_auth_get_key_list_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_key AUTH_GET_KEY Command  - Clause 7.4.59.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_key_get_controller_entity_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_key_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_AUTH_GET_KEY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_AUTH_GET_KEY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_KEY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_AUTH_GET_KEY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the COMMAND_AUTH_GET_KEY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_key_get_key_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the COMMAND_AUTH_GET_KEY object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_get_key AUTH_GET_KEY Command  - Clause 7.4.59.1 */
/*@{*/

/// AUTH_GET_KEY Command  - Clause 7.4.59.1
struct jdksavdecc_aem_command_auth_get_key {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_key structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_key structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_read(struct jdksavdecc_aem_command_auth_get_key *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_auth_get_key_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_key structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_key structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_write(struct jdksavdecc_aem_command_auth_get_key const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_key_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_key_response AUTH_GET_KEY Response  - Clause 7.4.59.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_key_response_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_key_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_key_response_get_key_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the COMMAND_AUTH_GET_KEY_RESPONSE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Extract the uint16 value of the key_type_key_length field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t key_type_key_length value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_response_get_key_type_key_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY_TYPE_KEY_LENGTH);
}

/**
 * Store a uint16 value to the key_type_key_length field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t key_type_key_length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_response_set_key_type_key_length(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_KEY_TYPE_KEY_LENGTH);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_key_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_AUTH_GET_KEY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_key_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_auth_get_key_response AUTH_GET_KEY Response  - Clause 7.4.59.2 */
/*@{*/

/// AUTH_GET_KEY Response  - Clause 7.4.59.2
struct jdksavdecc_aem_command_auth_get_key_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
    uint16_t key_type_key_length;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_key_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_key_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_response_read(struct jdksavdecc_aem_command_auth_get_key_response *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_auth_get_key_response_get_key_id(base, pos);
        p->key_type_key_length = jdksavdecc_aem_command_auth_get_key_response_get_key_type_key_length(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_get_key_response_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_key_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_key_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_key_response_write(
    struct jdksavdecc_aem_command_auth_get_key_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_key_response_set_key_id(p->key_id, base, pos);
        jdksavdecc_aem_command_auth_get_key_response_set_key_type_key_length(p->key_type_key_length, base, pos);
        jdksavdecc_aem_command_auth_get_key_response_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_add_key_to_chain AUTH_ADD_KEY_TO_CHAIN Command  -
 * Clause 7.4.60.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_to_chain_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_add_key_to_chain_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychain_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychain_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_get_keychain_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_KEYCHAIN_ID);
}

/**
 * Store a uint16 value to the keychain_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychain_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_set_keychain_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_KEYCHAIN_ID);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_to_chain_get_key_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the COMMAND_AUTH_ADD_KEY_TO_CHAIN
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_add_key_to_chain AUTH_ADD_KEY_TO_CHAIN Command  -
 * Clause 7.4.60.1 */
/*@{*/

/// AUTH_ADD_KEY_TO_CHAIN Command  - Clause 7.4.60.1
struct jdksavdecc_aem_command_auth_add_key_to_chain {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychain_id;
    uint16_t reserved;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_add_key_to_chain structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_add_key_to_chain structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_to_chain_read(struct jdksavdecc_aem_command_auth_add_key_to_chain *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychain_id = jdksavdecc_aem_command_auth_add_key_to_chain_get_keychain_id(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_add_key_to_chain_get_reserved(base, pos);
        p->key_id = jdksavdecc_aem_command_auth_add_key_to_chain_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_add_key_to_chain structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_add_key_to_chain structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_to_chain_write(
    struct jdksavdecc_aem_command_auth_add_key_to_chain const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_add_key_to_chain_set_keychain_id(p->keychain_id, base, pos);
        jdksavdecc_aem_command_auth_add_key_to_chain_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_auth_add_key_to_chain_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_add_key_to_chain_response AUTH_ADD_KEY_TO_CHAIN
 * Response  - Clause 7.4.60.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_add_key_to_chain_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                  void *base,
                                                                                                  ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychain_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychain_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_response_get_keychain_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_KEYCHAIN_ID);
}

/**
 * Store a uint16 value to the keychain_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychain_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_response_set_keychain_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_KEYCHAIN_ID);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_key_to_chain_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_key_to_chain_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_key_to_chain_response_get_key_id(void const *base,
                                                                                                       ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_add_key_to_chain_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_add_key_to_chain_response AUTH_ADD_KEY_TO_CHAIN
 * Response  - Clause 7.4.60.1 */
/*@{*/

/// AUTH_ADD_KEY_TO_CHAIN Response  - Clause 7.4.60.1
struct jdksavdecc_aem_command_auth_add_key_to_chain_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychain_id;
    uint16_t reserved;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_add_key_to_chain_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_add_key_to_chain_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_to_chain_response_read(
    struct jdksavdecc_aem_command_auth_add_key_to_chain_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychain_id = jdksavdecc_aem_command_auth_add_key_to_chain_response_get_keychain_id(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_add_key_to_chain_response_get_reserved(base, pos);
        p->key_id = jdksavdecc_aem_command_auth_add_key_to_chain_response_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_add_key_to_chain_response structure to
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_add_key_to_chain_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_key_to_chain_response_write(
    struct jdksavdecc_aem_command_auth_add_key_to_chain_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_KEY_TO_CHAIN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_add_key_to_chain_response_set_keychain_id(p->keychain_id, base, pos);
        jdksavdecc_aem_command_auth_add_key_to_chain_response_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_auth_add_key_to_chain_response_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_delete_key_from_chain AUTH_DELETE_KEY_FROM_CHAIN
 * Command  - Clause 7.4.61.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_delete_key_from_chain_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_from_chain_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_from_chain_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychain_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychain_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_get_keychain_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_KEYCHAIN_ID);
}

/**
 * Store a uint16 value to the keychain_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychain_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_from_chain_set_keychain_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_KEYCHAIN_ID);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_from_chain_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_key_from_chain_get_key_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_delete_key_from_chain AUTH_DELETE_KEY_FROM_CHAIN
 * Command  - Clause 7.4.61.1 */
/*@{*/

/// AUTH_DELETE_KEY_FROM_CHAIN Command  - Clause 7.4.61.1
struct jdksavdecc_aem_command_auth_delete_key_from_chain {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychain_id;
    uint16_t reserved;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_delete_key_from_chain structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_delete_key_from_chain structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_from_chain_read(
    struct jdksavdecc_aem_command_auth_delete_key_from_chain *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychain_id = jdksavdecc_aem_command_auth_delete_key_from_chain_get_keychain_id(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_delete_key_from_chain_get_reserved(base, pos);
        p->key_id = jdksavdecc_aem_command_auth_delete_key_from_chain_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_delete_key_from_chain structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_delete_key_from_chain structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_from_chain_write(
    struct jdksavdecc_aem_command_auth_delete_key_from_chain const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_delete_key_from_chain_set_keychain_id(p->keychain_id, base, pos);
        jdksavdecc_aem_command_auth_delete_key_from_chain_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_auth_delete_key_from_chain_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_delete_key_from_chain_response
 * AUTH_DELETE_KEY_FROM_CHAIN Response  - Clause 7.4.61.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_controller_entity_id(
    struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_sequence_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_command_type(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychain_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychain_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_keychain_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_KEYCHAIN_ID);
}

/**
 * Store a uint16 value to the keychain_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychain_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_keychain_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_KEYCHAIN_ID);
}

/**
 * Extract the uint16 value of the reserved field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_RESERVED);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_key_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_auth_delete_key_from_chain_response
 * AUTH_DELETE_KEY_FROM_CHAIN Response  - Clause 7.4.61.1 */
/*@{*/

/// AUTH_DELETE_KEY_FROM_CHAIN Response  - Clause 7.4.61.1
struct jdksavdecc_aem_command_auth_delete_key_from_chain_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychain_id;
    uint16_t reserved;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_delete_key_from_chain_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_delete_key_from_chain_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_from_chain_response_read(
    struct jdksavdecc_aem_command_auth_delete_key_from_chain_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychain_id = jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_keychain_id(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_reserved(base, pos);
        p->key_id = jdksavdecc_aem_command_auth_delete_key_from_chain_response_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_delete_key_from_chain_response
 *structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_delete_key_from_chain_response
 *structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_key_from_chain_response_write(
    struct jdksavdecc_aem_command_auth_delete_key_from_chain_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_KEY_FROM_CHAIN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_keychain_id(p->keychain_id, base, pos);
        jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_reserved(p->reserved, base, pos);
        jdksavdecc_aem_command_auth_delete_key_from_chain_response_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_keychain_list AUTH_GET_KEYCHAIN_LIST Command  -
 * Clause 7.4.62.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_keychain_list_get_controller_entity_id(void const *base,
                                                                                                             ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_keychain_list_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychain_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychain_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_get_keychain_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_KEYCHAIN_ID);
}

/**
 * Store a uint16 value to the keychain_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychain_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_set_keychain_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_KEYCHAIN_ID);
}

/**
 * Extract the uint16 value of the list_index field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t list_index value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_get_list_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_LIST_INDEX);
}

/**
 * Store a uint16 value to the list_index field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t list_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_set_list_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_OFFSET_LIST_INDEX);
}

/*@}*/

/** \addtogroup command_auth_get_keychain_list AUTH_GET_KEYCHAIN_LIST Command  -
 * Clause 7.4.62.1 */
/*@{*/

/// AUTH_GET_KEYCHAIN_LIST Command  - Clause 7.4.62.1
struct jdksavdecc_aem_command_auth_get_keychain_list {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychain_id;
    uint16_t list_index;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_keychain_list structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_keychain_list structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_keychain_list_read(
    struct jdksavdecc_aem_command_auth_get_keychain_list *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychain_id = jdksavdecc_aem_command_auth_get_keychain_list_get_keychain_id(base, pos);
        p->list_index = jdksavdecc_aem_command_auth_get_keychain_list_get_list_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_keychain_list structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_keychain_list structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_keychain_list_write(
    struct jdksavdecc_aem_command_auth_get_keychain_list const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_keychain_list_set_keychain_id(p->keychain_id, base, pos);
        jdksavdecc_aem_command_auth_get_keychain_list_set_list_index(p->list_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_keychain_list_response AUTH_GET_KEYCHAIN_LIST
 * Response  - Clause 7.4.62.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_get_keychain_list_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                   void *base,
                                                                                                   ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_keychain_list_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the keychain_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t keychain_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_response_get_keychain_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_KEYCHAIN_ID);
}

/**
 * Store a uint16 value to the keychain_id field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t keychain_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_response_set_keychain_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_KEYCHAIN_ID);
}

/**
 * Extract the uint16 value of the list_index field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t list_index value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_response_get_list_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_LIST_INDEX);
}

/**
 * Store a uint16 value to the list_index field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t list_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_keychain_list_response_set_list_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_LIST_INDEX);
}

/**
 * Extract the uint16 value of the number_of_lists field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_lists value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_response_get_number_of_lists(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_NUMBER_OF_LISTS);
}

/**
 * Store a uint16 value to the number_of_lists field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_lists value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_keychain_list_response_set_number_of_lists(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_NUMBER_OF_LISTS);
}

/**
 * Extract the uint16 value of the number_of_keys field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_keys value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_keychain_list_response_get_number_of_keys(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_NUMBER_OF_KEYS);
}

/**
 * Store a uint16 value to the number_of_keys field of the
 *COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_keys value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_keychain_list_response_set_number_of_keys(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_OFFSET_NUMBER_OF_KEYS);
}

/*@}*/

/** \addtogroup command_auth_get_keychain_list_response AUTH_GET_KEYCHAIN_LIST
 * Response  - Clause 7.4.62.2 */
/*@{*/

/// AUTH_GET_KEYCHAIN_LIST Response  - Clause 7.4.62.2
struct jdksavdecc_aem_command_auth_get_keychain_list_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t keychain_id;
    uint16_t list_index;
    uint16_t number_of_lists;
    uint16_t number_of_keys;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_keychain_list_response structure
 *from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_keychain_list_response structure to fill
 *in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_keychain_list_response_read(
    struct jdksavdecc_aem_command_auth_get_keychain_list_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->keychain_id = jdksavdecc_aem_command_auth_get_keychain_list_response_get_keychain_id(base, pos);
        p->list_index = jdksavdecc_aem_command_auth_get_keychain_list_response_get_list_index(base, pos);
        p->number_of_lists = jdksavdecc_aem_command_auth_get_keychain_list_response_get_number_of_lists(base, pos);
        p->number_of_keys = jdksavdecc_aem_command_auth_get_keychain_list_response_get_number_of_keys(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_keychain_list_response structure to
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_keychain_list_response structure
 *to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_keychain_list_response_write(
    struct jdksavdecc_aem_command_auth_get_keychain_list_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_KEYCHAIN_LIST_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_keychain_list_response_set_keychain_id(p->keychain_id, base, pos);
        jdksavdecc_aem_command_auth_get_keychain_list_response_set_list_index(p->list_index, base, pos);
        jdksavdecc_aem_command_auth_get_keychain_list_response_set_number_of_lists(p->number_of_lists, base, pos);
        jdksavdecc_aem_command_auth_get_keychain_list_response_set_number_of_keys(p->number_of_keys, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_identity AUTH_GET_IDENTITY Command  - Clause 7.4.63.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_IDENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_identity_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_IDENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_identity_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_IDENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_identity_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_IDENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_identity_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_IDENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_identity_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_IDENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_identity_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_auth_get_identity AUTH_GET_IDENTITY Command  - Clause 7.4.63.1 */
/*@{*/

/// AUTH_GET_IDENTITY Command  - Clause 7.4.63.1
struct jdksavdecc_aem_command_auth_get_identity {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_identity structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_identity structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_identity_read(struct jdksavdecc_aem_command_auth_get_identity *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_identity structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_identity structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_identity_write(struct jdksavdecc_aem_command_auth_get_identity const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_get_identity_response AUTH_GET_IDENTITY Response  -
 * Clause 7.4.62.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_get_identity_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_identity_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_identity_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_identity_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_get_identity_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_get_identity_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_entity_id field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_get_identity_response_get_key_entity_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_KEY_ENTITY_ID);
}

/**
 * Store a eui64 value to the key_entity_id field of the
 *COMMAND_AUTH_GET_IDENTITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_get_identity_response_set_key_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_OFFSET_KEY_ENTITY_ID);
}

/*@}*/

/** \addtogroup command_auth_get_identity_response AUTH_GET_IDENTITY Response  -
 * Clause 7.4.62.2 */
/*@{*/

/// AUTH_GET_IDENTITY Response  - Clause 7.4.62.2
struct jdksavdecc_aem_command_auth_get_identity_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_entity_id;
};

/**
 * Extract the jdksavdecc_aem_command_auth_get_identity_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_get_identity_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_identity_response_read(
    struct jdksavdecc_aem_command_auth_get_identity_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_entity_id = jdksavdecc_aem_command_auth_get_identity_response_get_key_entity_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_get_identity_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_get_identity_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_get_identity_response_write(
    struct jdksavdecc_aem_command_auth_get_identity_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_GET_IDENTITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_get_identity_response_set_key_entity_id(p->key_entity_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_add_token AUTH_ADD_TOKEN Command  - Clause 7.4.64.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_ADD_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_token_get_controller_entity_id(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_ADD_TOKEN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_add_token_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_ADD_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_token_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_AUTH_ADD_TOKEN
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_token_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_ADD_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_token_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_AUTH_ADD_TOKEN
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_token_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the token_length field of the
 *COMMAND_AUTH_ADD_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t token_length value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_token_get_token_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_TOKEN_LENGTH);
}

/**
 * Store a uint16 value to the token_length field of the COMMAND_AUTH_ADD_TOKEN
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t token_length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_token_set_token_length(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_TOKEN_LENGTH);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_AUTH_ADD_TOKEN
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_token_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_AUTH_ADD_TOKEN
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_token_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_auth_add_token AUTH_ADD_TOKEN Command  - Clause 7.4.64.1
 */
/*@{*/

/// AUTH_ADD_TOKEN Command  - Clause 7.4.64.1
struct jdksavdecc_aem_command_auth_add_token {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t token_length;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_auth_add_token structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_add_token structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_token_read(struct jdksavdecc_aem_command_auth_add_token *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->token_length = jdksavdecc_aem_command_auth_add_token_get_token_length(base, pos);
        p->reserved = jdksavdecc_aem_command_auth_add_token_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_add_token structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_add_token structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_token_write(struct jdksavdecc_aem_command_auth_add_token const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_auth_add_token_set_token_length(p->token_length, base, pos);
        jdksavdecc_aem_command_auth_add_token_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_add_token_response AUTH_ADD_TOKEN Response  -
 * Clause 7.4.64.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_ADD_TOKEN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_add_token_response_get_controller_entity_id(void const *base,
                                                                                                              ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_ADD_TOKEN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_add_token_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_ADD_TOKEN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_token_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_ADD_TOKEN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_token_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_ADD_TOKEN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_add_token_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_ADD_TOKEN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_add_token_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_auth_add_token_response AUTH_ADD_TOKEN Response  -
 * Clause 7.4.64.2 */
/*@{*/

/// AUTH_ADD_TOKEN Response  - Clause 7.4.64.2
struct jdksavdecc_aem_command_auth_add_token_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_auth_add_token_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_add_token_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_token_response_read(
    struct jdksavdecc_aem_command_auth_add_token_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_add_token_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_add_token_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_add_token_response_write(
    struct jdksavdecc_aem_command_auth_add_token_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_ADD_TOKEN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_delete_token AUTH_DELETE_TOKEN Command  - Clause 7.4.65.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_auth_delete_token_get_controller_entity_id(void const *base,
                                                                                                        ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_TOKEN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_token_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_DELETE_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_token_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_DELETE_TOKEN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_token_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_DELETE_TOKEN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_token_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_DELETE_TOKEN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_token_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_auth_delete_token AUTH_DELETE_TOKEN Command  - Clause 7.4.65.1 */
/*@{*/

/// AUTH_DELETE_TOKEN Command  - Clause 7.4.65.1
struct jdksavdecc_aem_command_auth_delete_token {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_auth_delete_token structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_delete_token structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_token_read(struct jdksavdecc_aem_command_auth_delete_token *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_delete_token structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_delete_token structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_token_write(struct jdksavdecc_aem_command_auth_delete_token const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_auth_delete_token_response AUTH_DELETE_TOKEN Response  -
 * Clause 7.4.65.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_TOKEN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_auth_delete_token_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTH_DELETE_TOKEN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_auth_delete_token_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTH_DELETE_TOKEN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_token_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTH_DELETE_TOKEN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_token_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTH_DELETE_TOKEN_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_auth_delete_token_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTH_DELETE_TOKEN_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_auth_delete_token_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_auth_delete_token_response AUTH_DELETE_TOKEN Response  -
 * Clause 7.4.65.1 */
/*@{*/

/// AUTH_DELETE_TOKEN Response  - Clause 7.4.65.1
struct jdksavdecc_aem_command_auth_delete_token_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_auth_delete_token_response structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_auth_delete_token_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_token_response_read(
    struct jdksavdecc_aem_command_auth_delete_token_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_auth_delete_token_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_auth_delete_token_response structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_auth_delete_token_response_write(
    struct jdksavdecc_aem_command_auth_delete_token_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTH_DELETE_TOKEN_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_authenticate AUTHENTICATE Command  - Clause 7.4.66.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_authenticate_get_controller_entity_id(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTHENTICATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_authenticate_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the COMMAND_AUTHENTICATE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_AUTHENTICATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_AUTHENTICATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_AUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the COMMAND_AUTHENTICATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_AUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_AUTHENTICATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the token_length field of the
 *COMMAND_AUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t token_length value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_get_token_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_TOKEN_LENGTH);
}

/**
 * Store a uint16 value to the token_length field of the COMMAND_AUTHENTICATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t token_length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_set_token_length(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_TOKEN_LENGTH);
}

/**
 * Extract the uint16 value of the reserved field of the COMMAND_AUTHENTICATE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t reserved value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_get_reserved(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_RESERVED);
}

/**
 * Store a uint16 value to the reserved field of the COMMAND_AUTHENTICATE object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t reserved value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_set_reserved(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_OFFSET_RESERVED);
}

/*@}*/

/** \addtogroup command_authenticate AUTHENTICATE Command  - Clause 7.4.66.1 */
/*@{*/

/// AUTHENTICATE Command  - Clause 7.4.66.1
struct jdksavdecc_aem_command_authenticate {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t token_length;
    uint16_t reserved;
};

/**
 * Extract the jdksavdecc_aem_command_authenticate structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_authenticate structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_authenticate_read(struct jdksavdecc_aem_command_authenticate *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_authenticate_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_authenticate_get_descriptor_index(base, pos);
        p->token_length = jdksavdecc_aem_command_authenticate_get_token_length(base, pos);
        p->reserved = jdksavdecc_aem_command_authenticate_get_reserved(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_authenticate structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_authenticate structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_authenticate_write(struct jdksavdecc_aem_command_authenticate const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_authenticate_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_authenticate_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_authenticate_set_token_length(p->token_length, base, pos);
        jdksavdecc_aem_command_authenticate_set_reserved(p->reserved, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_authenticate_response AUTHENTICATE Response  - Clause 7.4.66.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_AUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_authenticate_response_get_controller_entity_id(void const *base,
                                                                                                            ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_AUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_authenticate_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_AUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_AUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_AUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_AUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_AUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_AUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_AUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_authenticate_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_AUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_authenticate_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_authenticate_response AUTHENTICATE Response  - Clause 7.4.66.1 */
/*@{*/

/// AUTHENTICATE Response  - Clause 7.4.66.1
struct jdksavdecc_aem_command_authenticate_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_authenticate_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_authenticate_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_authenticate_response_read(struct jdksavdecc_aem_command_authenticate_response *p,
                                                                        void const *base,
                                                                        ssize_t pos,
                                                                        size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_authenticate_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_authenticate_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_authenticate_response structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_authenticate_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_authenticate_response_write(
    struct jdksavdecc_aem_command_authenticate_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_AUTHENTICATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_authenticate_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_authenticate_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_deauthenticate DEAUTHENTICATE Command  - Clause 7.4.67.1
 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DEAUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_deauthenticate_get_controller_entity_id(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DEAUTHENTICATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_deauthenticate_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DEAUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the COMMAND_DEAUTHENTICATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DEAUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the COMMAND_DEAUTHENTICATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_DEAUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_DEAUTHENTICATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_DEAUTHENTICATE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_DEAUTHENTICATE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_deauthenticate DEAUTHENTICATE Command  - Clause 7.4.67.1
 */
/*@{*/

/// DEAUTHENTICATE Command  - Clause 7.4.67.1
struct jdksavdecc_aem_command_deauthenticate {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_deauthenticate structure from a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_deauthenticate structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deauthenticate_read(struct jdksavdecc_aem_command_deauthenticate *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_deauthenticate_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_deauthenticate_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_deauthenticate structure to a network
 *buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_deauthenticate structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deauthenticate_write(struct jdksavdecc_aem_command_deauthenticate const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_deauthenticate_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_deauthenticate_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_deauthenticate_response DEAUTHENTICATE Response  -
 * Clause 7.4.67.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_deauthenticate_response_get_controller_entity_id(void const *base,
                                                                                                              ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_deauthenticate_response_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_response_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_response_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_deauthenticate_response_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_DEAUTHENTICATE_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_deauthenticate_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_deauthenticate_response DEAUTHENTICATE Response  -
 * Clause 7.4.67.1 */
/*@{*/

/// DEAUTHENTICATE Response  - Clause 7.4.67.1
struct jdksavdecc_aem_command_deauthenticate_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_deauthenticate_response structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_deauthenticate_response structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deauthenticate_response_read(
    struct jdksavdecc_aem_command_deauthenticate_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_deauthenticate_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_deauthenticate_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_deauthenticate_response structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_deauthenticate_response structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_deauthenticate_response_write(
    struct jdksavdecc_aem_command_deauthenticate_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DEAUTHENTICATE_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_deauthenticate_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_deauthenticate_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_enable_transport_security ENABLE_TRANSPORT_SECURITY
 * Command  - Clause 7.4.68.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_enable_transport_security_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_transport_security_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_enable_transport_security_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_transport_security_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_enable_transport_security_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_transport_security_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_enable_transport_security_get_key_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_transport_security_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_enable_transport_security ENABLE_TRANSPORT_SECURITY
 * Command  - Clause 7.4.68.1 */
/*@{*/

/// ENABLE_TRANSPORT_SECURITY Command  - Clause 7.4.68.1
struct jdksavdecc_aem_command_enable_transport_security {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_enable_transport_security structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_enable_transport_security structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_transport_security_read(
    struct jdksavdecc_aem_command_enable_transport_security *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_enable_transport_security_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_enable_transport_security structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_enable_transport_security structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_transport_security_write(
    struct jdksavdecc_aem_command_enable_transport_security const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_enable_transport_security_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_enable_transport_security_response
 * ENABLE_TRANSPORT_SECURITY Response  - Clause 7.4.68.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_enable_transport_security_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_transport_security_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                      void *base,
                                                                                                      ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_enable_transport_security_response_get_sequence_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_transport_security_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_enable_transport_security_response_get_command_type(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_transport_security_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_enable_transport_security_response_get_key_id(void const *base,
                                                                                                           ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_transport_security_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_enable_transport_security_response
 * ENABLE_TRANSPORT_SECURITY Response  - Clause 7.4.68.1 */
/*@{*/

/// ENABLE_TRANSPORT_SECURITY Response  - Clause 7.4.68.1
struct jdksavdecc_aem_command_enable_transport_security_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_enable_transport_security_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_enable_transport_security_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_transport_security_response_read(
    struct jdksavdecc_aem_command_enable_transport_security_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->key_id = jdksavdecc_aem_command_enable_transport_security_response_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_enable_transport_security_response structure
 *to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_enable_transport_security_response
 *structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_transport_security_response_write(
    struct jdksavdecc_aem_command_enable_transport_security_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_TRANSPORT_SECURITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_enable_transport_security_response_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_disable_transport_security DISABLE_TRANSPORT_SECURITY
 * Command  - Clause 7.4.69.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_disable_transport_security_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_transport_security_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_disable_transport_security_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_transport_security_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_disable_transport_security_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_transport_security_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_disable_transport_security DISABLE_TRANSPORT_SECURITY
 * Command  - Clause 7.4.69.1 */
/*@{*/

/// DISABLE_TRANSPORT_SECURITY Command  - Clause 7.4.69.1
struct jdksavdecc_aem_command_disable_transport_security {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_disable_transport_security structure from
 *a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_disable_transport_security structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_transport_security_read(
    struct jdksavdecc_aem_command_disable_transport_security *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_disable_transport_security structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_disable_transport_security structure to
 *read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_transport_security_write(
    struct jdksavdecc_aem_command_disable_transport_security const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_disable_transport_security_response
 * DISABLE_TRANSPORT_SECURITY Response  - Clause 7.4.69.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE object from a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_disable_transport_security_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_transport_security_response_set_controller_entity_id(
    struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_disable_transport_security_response_get_sequence_id(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_transport_security_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_disable_transport_security_response_get_command_type(void const *base,
                                                                                                   ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_transport_security_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_OFFSET_COMMAND_TYPE);
}

/*@}*/

/** \addtogroup command_disable_transport_security_response
 * DISABLE_TRANSPORT_SECURITY Response  - Clause 7.4.69.1 */
/*@{*/

/// DISABLE_TRANSPORT_SECURITY Response  - Clause 7.4.69.1
struct jdksavdecc_aem_command_disable_transport_security_response {
    struct jdksavdecc_aecpdu_aem aem_header;
};

/**
 * Extract the jdksavdecc_aem_command_disable_transport_security_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_disable_transport_security_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_transport_security_response_read(
    struct jdksavdecc_aem_command_disable_transport_security_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_disable_transport_security_response
 *structure to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_disable_transport_security_response
 *structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_transport_security_response_write(
    struct jdksavdecc_aem_command_disable_transport_security_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_TRANSPORT_SECURITY_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
    }
    return r;
}

/*@}*/

/** \addtogroup command_enable_stream_encryption ENABLE_STREAM_ENCRYPTION
 * Command  - Clause 7.4.70.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_enable_stream_encryption_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_stream_encryption_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_stream_encryption_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_stream_encryption_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_stream_encryption_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_enable_stream_encryption_get_key_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_enable_stream_encryption ENABLE_STREAM_ENCRYPTION
 * Command  - Clause 7.4.70.1 */
/*@{*/

/// ENABLE_STREAM_ENCRYPTION Command  - Clause 7.4.70.1
struct jdksavdecc_aem_command_enable_stream_encryption {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_enable_stream_encryption structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_enable_stream_encryption structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_stream_encryption_read(
    struct jdksavdecc_aem_command_enable_stream_encryption *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_enable_stream_encryption_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_enable_stream_encryption_get_descriptor_index(base, pos);
        p->key_id = jdksavdecc_aem_command_enable_stream_encryption_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_enable_stream_encryption structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_enable_stream_encryption structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_stream_encryption_write(
    struct jdksavdecc_aem_command_enable_stream_encryption const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_enable_stream_encryption_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_enable_stream_encryption_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_enable_stream_encryption_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_enable_stream_encryption_response
 * ENABLE_STREAM_ENCRYPTION Response  - Clause 7.4.70.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_enable_stream_encryption_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_enable_stream_encryption_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                     void *base,
                                                                                                     ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_response_get_command_type(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_response_get_descriptor_type(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_enable_stream_encryption_response_get_descriptor_index(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the key_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 key_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_enable_stream_encryption_response_get_key_id(void const *base,
                                                                                                          ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_KEY_ID);
}

/**
 * Store a eui64 value to the key_id field of the
 *COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 key_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_enable_stream_encryption_response_set_key_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_KEY_ID);
}

/*@}*/

/** \addtogroup command_enable_stream_encryption_response
 * ENABLE_STREAM_ENCRYPTION Response  - Clause 7.4.70.1 */
/*@{*/

/// ENABLE_STREAM_ENCRYPTION Response  - Clause 7.4.70.1
struct jdksavdecc_aem_command_enable_stream_encryption_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 key_id;
};

/**
 * Extract the jdksavdecc_aem_command_enable_stream_encryption_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_enable_stream_encryption_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_stream_encryption_response_read(
    struct jdksavdecc_aem_command_enable_stream_encryption_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_enable_stream_encryption_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_enable_stream_encryption_response_get_descriptor_index(base, pos);
        p->key_id = jdksavdecc_aem_command_enable_stream_encryption_response_get_key_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_enable_stream_encryption_response structure
 *to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_enable_stream_encryption_response structure
 *to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_enable_stream_encryption_response_write(
    struct jdksavdecc_aem_command_enable_stream_encryption_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_ENABLE_STREAM_ENCRYPTION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_enable_stream_encryption_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_enable_stream_encryption_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_enable_stream_encryption_response_set_key_id(p->key_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_disable_stream_encryption DISABLE_STREAM_ENCRYPTION
 * Command  - Clause 7.4.71.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_disable_stream_encryption_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_stream_encryption_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_stream_encryption_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_stream_encryption_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_stream_encryption_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_stream_encryption_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_disable_stream_encryption DISABLE_STREAM_ENCRYPTION
 * Command  - Clause 7.4.71.1 */
/*@{*/

/// DISABLE_STREAM_ENCRYPTION Command  - Clause 7.4.71.1
struct jdksavdecc_aem_command_disable_stream_encryption {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_disable_stream_encryption structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_disable_stream_encryption structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_stream_encryption_read(
    struct jdksavdecc_aem_command_disable_stream_encryption *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_disable_stream_encryption_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_disable_stream_encryption_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_disable_stream_encryption structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_disable_stream_encryption structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_stream_encryption_write(
    struct jdksavdecc_aem_command_disable_stream_encryption const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_disable_stream_encryption_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_disable_stream_encryption_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_disable_stream_encryption_response
 * DISABLE_STREAM_ENCRYPTION Response  - Clause 7.4.71.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_disable_stream_encryption_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_disable_stream_encryption_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                      void *base,
                                                                                                      ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_response_get_sequence_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_stream_encryption_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_response_get_command_type(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_stream_encryption_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_response_get_descriptor_type(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_stream_encryption_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_disable_stream_encryption_response_get_descriptor_index(void const *base,
                                                                                                      ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_disable_stream_encryption_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/*@}*/

/** \addtogroup command_disable_stream_encryption_response
 * DISABLE_STREAM_ENCRYPTION Response  - Clause 7.4.71.1 */
/*@{*/

/// DISABLE_STREAM_ENCRYPTION Response  - Clause 7.4.71.1
struct jdksavdecc_aem_command_disable_stream_encryption_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_disable_stream_encryption_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_disable_stream_encryption_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_stream_encryption_response_read(
    struct jdksavdecc_aem_command_disable_stream_encryption_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_disable_stream_encryption_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_disable_stream_encryption_response_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_disable_stream_encryption_response structure
 *to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_disable_stream_encryption_response
 *structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_disable_stream_encryption_response_write(
    struct jdksavdecc_aem_command_disable_stream_encryption_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_DISABLE_STREAM_ENCRYPTION_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_disable_stream_encryption_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_disable_stream_encryption_response_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_memory_object_length SET_MEMORY_OBJECT_LENGTH
 * Command  - Clause 7.4.72.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_set_memory_object_length_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_memory_object_length_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint64_t value of the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint64_t length value
 */
static inline uint64_t jdksavdecc_aem_command_set_memory_object_length_get_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_LENGTH);
}

/**
 * Store a uint64_t value to the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint64_t length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_set_length(uint64_t v, void *base, ssize_t pos) {
    jdksavdecc_uint64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_LENGTH);
}
/*@}*/

/** \addtogroup command_set_memory_object_length SET_MEMORY_OBJECT_LENGTH
 * Command  - Clause 7.4.72.1 */
/*@{*/

/// SET_MEMORY_OBJECT_LENGTH Command  - Clause 7.4.72.1
struct jdksavdecc_aem_command_set_memory_object_length {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint64_t length;
};

/**
 * Extract the jdksavdecc_aem_command_set_memory_object_length structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_memory_object_length structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_memory_object_length_read(
    struct jdksavdecc_aem_command_set_memory_object_length *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_memory_object_length_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_memory_object_length_get_descriptor_index(base, pos);
        p->length = jdksavdecc_aem_command_set_memory_object_length_get_length(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_memory_object_length structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_memory_object_length structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_memory_object_length_write(
    struct jdksavdecc_aem_command_set_memory_object_length const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_memory_object_length_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_memory_object_length_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_memory_object_length_set_length(p->length, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_set_memory_object_length_response
 * SET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.72.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_set_memory_object_length_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                     void *base,
                                                                                                     ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_memory_object_length_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_response_get_command_type(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_memory_object_length_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_response_get_descriptor_type(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_memory_object_length_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_set_memory_object_length_response_get_descriptor_index(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_set_memory_object_length_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint64_t value of the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint64_t length value
 */
static inline uint64_t jdksavdecc_aem_command_set_memory_object_length_response_get_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint64_get(base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_LENGTH);
}

/**
 * Store a uint64_t value to the descriptor_index field of the
 *COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint64_t length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_set_memory_object_length_response_set_length(uint64_t v, void *base, ssize_t pos) {
    jdksavdecc_uint64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_LENGTH);
}
/*@}*/

/** \addtogroup command_set_memory_object_length_response
 * SET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.72.2 */
/*@{*/

/// SET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.72.2
struct jdksavdecc_aem_command_set_memory_object_length_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint64_t length;
};

/**
 * Extract the jdksavdecc_aem_command_set_memory_object_length_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_set_memory_object_length_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_memory_object_length_response_read(
    struct jdksavdecc_aem_command_set_memory_object_length_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_set_memory_object_length_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_set_memory_object_length_response_get_descriptor_index(base, pos);
        p->length = jdksavdecc_aem_command_set_memory_object_length_response_get_length(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_set_memory_object_length_response structure
 *to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_set_memory_object_length_response structure
 *to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_set_memory_object_length_response_write(
    struct jdksavdecc_aem_command_set_memory_object_length_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_SET_MEMORY_OBJECT_LENGTH_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_set_memory_object_length_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_set_memory_object_length_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_set_memory_object_length_response_set_length(p->length, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_get_memory_object_length GET_MEMORY_OBJECT_LENGTH
 * Command  - Clause 7.4.73.1 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_aem_command_get_memory_object_length_get_controller_entity_id(void const *base,
                                                                                                               ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_memory_object_length_set_controller_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_memory_object_length_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_get_command_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_memory_object_length_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_memory_object_length_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_memory_object_length_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_OFFSET_DESCRIPTOR_INDEX);
}
/*@}*/

/** \addtogroup command_get_memory_object_length GET_MEMORY_OBJECT_LENGTH
 * Command  - Clause 7.4.73.1 */
/*@{*/

/// SET_MEMORY_OBJECT_LENGTH Command  - Clause 7.4.73.1
struct jdksavdecc_aem_command_get_memory_object_length {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
};

/**
 * Extract the jdksavdecc_aem_command_get_memory_object_length structure from a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_memory_object_length structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_memory_object_length_read(
    struct jdksavdecc_aem_command_get_memory_object_length *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_memory_object_length_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_memory_object_length_get_descriptor_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_memory_object_length structure to a
 *network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_memory_object_length structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_memory_object_length_write(
    struct jdksavdecc_aem_command_get_memory_object_length const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_COMMAND_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_memory_object_length_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_memory_object_length_set_descriptor_index(p->descriptor_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup command_aem_get_memory_object_length_response
 * SET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.73.2 */
/*@{*/

/**
 * Extract the eui64 value of the controller_entity_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 controller_entity_id value
 */
static inline struct jdksavdecc_eui64
jdksavdecc_aem_command_get_memory_object_length_response_get_controller_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base,
                                pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Store a eui64 value to the controller_entity_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 controller_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_memory_object_length_response_set_controller_entity_id(struct jdksavdecc_eui64 v,
                                                                                                     void *base,
                                                                                                     ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_CONTROLLER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the sequence_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sequence_id value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_response_get_sequence_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Store a uint16 value to the sequence_id field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sequence_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_memory_object_length_response_set_sequence_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_SEQUENCE_ID);
}

/**
 * Extract the uint16 value of the command_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t command_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_response_get_command_type(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Store a uint16 value to the command_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t command_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_memory_object_length_response_set_command_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_COMMAND_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_response_get_descriptor_type(void const *base,
                                                                                                    ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_memory_object_length_response_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_aem_command_get_memory_object_length_response_get_descriptor_index(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_aem_command_get_memory_object_length_response_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint64_t value of the descriptor_index field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint64_t length value
 */
static inline uint64_t jdksavdecc_aem_command_get_memory_object_length_response_get_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint64_get(base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_LENGTH);
}

/**
 * Store a uint64_t value to the descriptor_index field of the
 *COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint64_t length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_aem_command_get_memory_object_length_response_set_length(uint64_t v, void *base, ssize_t pos) {
    jdksavdecc_uint64_set(v, base, pos + JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_OFFSET_LENGTH);
}
/*@}*/

/** \addtogroup command_get_memory_object_length_response
 * GET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.73.2 */
/*@{*/

/// SET_MEMORY_OBJECT_LENGTH Response  - Clause 7.4.73.2
struct jdksavdecc_aem_command_get_memory_object_length_response {
    struct jdksavdecc_aecpdu_aem aem_header;
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint64_t length;
};

/**
 * Extract the jdksavdecc_aem_command_get_memory_object_length_response
 *structure from a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to command_get_memory_object_length_response structure to
 *fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_memory_object_length_response_read(
    struct jdksavdecc_aem_command_get_memory_object_length_response *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_read(&p->aem_header, base, pos, len);
        p->descriptor_type = jdksavdecc_aem_command_get_memory_object_length_response_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_aem_command_get_memory_object_length_response_get_descriptor_index(base, pos);
        p->length = jdksavdecc_aem_command_get_memory_object_length_response_get_length(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_aem_command_get_memory_object_length_response structure
 *to a network buffer.
 *
 *
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to command_get_memory_object_length_response structure
 *to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_aem_command_get_memory_object_length_response_write(
    struct jdksavdecc_aem_command_get_memory_object_length_response const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AEM_COMMAND_GET_MEMORY_OBJECT_LENGTH_RESPONSE_LEN);
    if (r >= 0) {
        jdksavdecc_aecpdu_aem_write(&p->aem_header, base, pos, len);
        jdksavdecc_aem_command_get_memory_object_length_response_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_aem_command_get_memory_object_length_response_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_aem_command_get_memory_object_length_response_set_length(p->length, base, pos);
    }
    return r;
}

/** @todo Add read/write for the set/get stream backup commands and responses */
struct jdksavdecc_aem_command_set_stream_backup;
/** @todo Add read/write for the set/get stream backup commands and responses */
struct jdksavdecc_aem_command_set_stream_backup_response;
/** @todo Add read/write for the set/get stream backup commands and responses */
struct jdksavdecc_aem_command_get_stream_backup;
/** @todo Add read/write for the set/get stream backup commands and responses */
struct jdksavdecc_aem_command_get_stream_backup_response;

/** \addtogroup get_counters_entity_bits get_counters_entity_bits : counters_valid field for ENTITY descriptor - Clause
 * 7.4.42.2.1  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_8_BIT (7)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_8 (0x01000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_8_MASK (~(0x01000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_7_BIT (6)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_7 (0x02000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_7_MASK (~(0x02000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_6_BIT (5)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_6 (0x04000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_6_MASK (~(0x04000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_5_BIT (4)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_5 (0x08000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_5_MASK (~(0x08000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_4_BIT (3)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_4 (0x10000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_4_MASK (~(0x10000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_3_BIT (2)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_3 (0x20000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_3_MASK (~(0x20000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_2_BIT (1)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_2 (0x40000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_2_MASK (~(0x40000000UL))
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_1_BIT (0)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_1 (0x80000000UL)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_BITS_ENTITY_SPECIFIC_1_MASK (~(0x80000000UL))

/*@}*/

/** \addtogroup get_counters_avb_interface_bits get_counters_avb_interface_bits : counters_valid field for AVB_INTERFACE
 * descriptor - Clause 7.4.42.2.2  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_LINK_UP_BIT (31)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_LINK_UP (0x00000001UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_LINK_UP_MASK (~(0x00000001UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_LINK_DOWN_BIT (30)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_LINK_DOWN (0x00000002UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_LINK_DOWN_MASK (~(0x00000002UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_PACKETS_TX_BIT (29)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_PACKETS_TX (0x00000004UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_PACKETS_TX_MASK (~(0x00000004UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_PACKETS_RX_BIT (28)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_PACKETS_RX (0x00000008UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_PACKETS_RX_MASK (~(0x00000008UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_RX_CRC_ERROR_BIT (27)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_RX_CRC_ERROR (0x00000010UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_RX_CRC_ERROR_MASK (~(0x00000010UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_GPTP_GM_CHANGED_BIT (26)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_GPTP_GM_CHANGED (0x00000020UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_GPTP_GM_CHANGED_MASK (~(0x00000020UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_8_BIT (7)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_8 (0x01000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_8_MASK (~(0x01000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_7_BIT (6)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_7 (0x02000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_7_MASK (~(0x02000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_6_BIT (5)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_6 (0x04000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_6_MASK (~(0x04000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_5_BIT (4)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_5 (0x08000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_5_MASK (~(0x08000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_4_BIT (3)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_4 (0x10000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_4_MASK (~(0x10000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_3_BIT (2)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_3 (0x20000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_3_MASK (~(0x20000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_2_BIT (1)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_2 (0x40000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_2_MASK (~(0x40000000UL))
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_1_BIT (0)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_1 (0x80000000UL)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_BITS_ENTITY_SPECIFIC_1_MASK (~(0x80000000UL))

/*@}*/

/** \addtogroup get_counters_clock_domain_bits get_counters_clock_domain_bits : counters_valid field for CLOCK_DOMAIN descriptor
 * - Clause 7.4.42.2.3  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_LOCKED_BIT (31)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_LOCKED (0x00000001UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_LOCKED_MASK (~(0x00000001UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_UNLOCKED_BIT (30)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_UNLOCKED (0x00000002UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_UNLOCKED_MASK (~(0x00000002UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_1_BIT (7)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_1 (0x01000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_1_MASK (~(0x01000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_2_BIT (6)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_2 (0x02000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_2_MASK (~(0x02000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_3_BIT (5)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_3 (0x04000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_3_MASK (~(0x04000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_4_BIT (4)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_4 (0x08000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_4_MASK (~(0x08000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_5_BIT (3)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_5 (0x10000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_5_MASK (~(0x10000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_6_BIT (2)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_6 (0x20000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_6_MASK (~(0x20000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_7_BIT (1)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_7 (0x40000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_7_MASK (~(0x40000000UL))
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_8_BIT (0)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_8 (0x80000000UL)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_BITS_ENTITY_SPECIFIC_8_MASK (~(0x80000000UL))

/*@}*/

/** \addtogroup get_counters_stream_input_bits get_counters_stream_input_bits : counters_valid field for STREAM_INPUT descriptor
 * - Clause 7.4.42.2.4  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_LOCKED_BIT (31)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_LOCKED (0x00000001UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_LOCKED_MASK (~(0x00000001UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_UNLOCKED_BIT (30)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_UNLOCKED (0x00000002UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_UNLOCKED_MASK (~(0x00000002UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_STREAM_RESET_BIT (29)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_STREAM_RESET (0x00000004UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_STREAM_RESET_MASK (~(0x00000004UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_SEQ_NUM_MISMATCH_BIT (28)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_SEQ_NUM_MISMATCH (0x00000008UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_SEQ_NUM_MISMATCH_MASK (~(0x00000008UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_RESET_BIT (27)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_RESET (0x00000010UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_MEDIA_RESET_MASK (~(0x00000010UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_UNCERTAIN_BIT (26)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_UNCERTAIN (0x00000020UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_UNCERTAIN_MASK (~(0x00000020UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_VALID_BIT (25)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_VALID (0x00000040UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_VALID_MASK (~(0x00000040UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_NOT_VALID_BIT (24)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_NOT_VALID (0x00000080UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_TIMESTAMP_NOT_VALID_MASK (~(0x00000080UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_UNSUPPORTED_FORMAT_BIT (23)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_UNSUPPORTED_FORMAT (0x00000100UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_UNSUPPORTED_FORMAT_MASK (~(0x00000100UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_LATE_TIMESTAMP_BIT (22)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_LATE_TIMESTAMP (0x00000200UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_LATE_TIMESTAMP_MASK (~(0x00000200UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_EARLY_TIMESTAMP_BIT (21)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_EARLY_TIMESTAMP (0x00000400UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_EARLY_TIMESTAMP_MASK (~(0x00000400UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_PACKETS_RX_BIT (20)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_PACKETS_RX (0x00000800UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_PACKETS_RX_MASK (~(0x00000800UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_PACKETS_TX_BIT (19)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_PACKETS_TX (0x00001000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_PACKETS_TX_MASK (~(0x00001000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_8_BIT (7)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_8 (0x01000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_8_MASK (~(0x01000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_7_BIT (6)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_7 (0x02000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_7_MASK (~(0x02000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_6_BIT (5)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_6 (0x04000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_6_MASK (~(0x04000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_5_BIT (4)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_5 (0x08000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_5_MASK (~(0x08000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_4_BIT (3)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_4 (0x10000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_4_MASK (~(0x10000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_3_BIT (2)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_3 (0x20000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_3_MASK (~(0x20000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_2_BIT (1)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_2 (0x40000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_2_MASK (~(0x40000000UL))
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_1_BIT (0)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_1 (0x80000000UL)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_BITS_ENTITY_SPECIFIC_1_MASK (~(0x80000000UL))

/*@}*/

/** \addtogroup get_counters_entity get_counters_entity : Counter offsets in counters_block for the ENTITY descriptor - Clause
 * 7.4.42.2.1  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_8 (96)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_7 (100)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_6 (104)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_5 (108)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_4 (112)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_3 (116)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_2 (120)
#define JDKSAVDECC_GET_COUNTERS_ENTITY_OFFSET_ENTITY_SPECIFIC_1 (124)

/*@}*/

/** \addtogroup get_counters_avb_interface get_counters_avb_interface : Counter offsets in counters_block for the AVB_INTERFACE
 * descriptor - Clause 7.4.42.2.2  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_LINK_UP (0)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_LINK_DOWN (4)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_PACKETS_TX (8)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_PACKETS_RX (12)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_RX_CRC_ERROR (16)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_GPTP_GM_CHANGED (20)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_8 (96)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_7 (100)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_6 (104)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_5 (108)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_4 (112)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_3 (116)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_2 (120)
#define JDKSAVDECC_GET_COUNTERS_AVB_INTERFACE_OFFSET_ENTITY_SPECIFIC_1 (124)

/*@}*/

/** \addtogroup get_counters_clock_domain get_counters_clock_domain : Counter offsets in counters_block for the CLOCK_DOMAIN
 * descriptor - Clause 7.4.42.2.3  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_LOCKED (0)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_UNLOCKED (4)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_8 (96)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_7 (100)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_6 (104)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_5 (108)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_4 (112)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_3 (116)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_2 (120)
#define JDKSAVDECC_GET_COUNTERS_CLOCK_DOMAIN_OFFSET_ENTITY_SPECIFIC_1 (124)

/*@}*/

/** \addtogroup get_counters_stream_input get_counters_stream_input : Counter offsets in counters_block for the STREAM_INPUT
 * descriptor - Clause 7.4.42.2.4  */
/*@{*/

#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_MEDIA_LOCKED (0)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_MEDIA_UNLOCKED (4)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_STREAM_RESET (8)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_SEQ_NUM_MISMATCH (12)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_MEDIA_RESET (16)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_TIMESTAMP_UNCERTAIN (20)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_TIMESTAMP_VALID (24)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_TIMESTAMP_NOT_VALID (28)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_UNSUPPORTED_FORMAT (32)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_LATE_TIMESTAMP (36)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_EARLY_TIMESTAMP (40)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_PACKETS_RX (44)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_PACKETS_TX (48)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_1 (96)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_2 (100)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_3 (104)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_4 (108)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_5 (112)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_6 (116)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_7 (120)
#define JDKSAVDECC_GET_COUNTERS_STREAM_INPUT_OFFSET_ENTITY_SPECIFIC_8 (124)

/*@}*/

/*@}*/

/*@}*/

/*@}*/

#ifdef __cplusplus
}
#endif
